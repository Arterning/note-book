# 管道

- 管道是具有 `@Injectable()` 装饰器的类。
- 管道应实现 `PipeTransform` 接口。

有两个典型的应用场景:

- **转换**：管道将输入数据转换为所需的数据输出(例如，将字符串转换为整数)
- **验证**：对输入数据进行验证，如果验证成功继续传递; 验证失败则抛出异常

自带管道

- `ValidationPipe`
- `ParseIntPipe`
- `ParseFloatPipe`
- `ParseBoolPipe`
- `ParseArrayPipe`
- `ParseUUIDPipe`
- `ParseEnumPipe`
- `DefaultValuePipe`
- `ParseFilePipe`

快速看看如何使用`ParseIntPipe`

前端http报文传递的东东都是字符串，如果要转换为数字，在express中需要手动转换，比如parseInt

在这里就可以直接使用管道了，非常方便。

递了一个类(`ParseIntPipe`)

```jsx
@Get(':id')
async findOne(@Param('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
```

也可以选择传递一个实例。如果我们想通过传递选项来自定义内置管道的行为

```jsx
@Get(':id')
async findOne(
  @Param('id', new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE }))
  id: number,
) {
  return this.catsService.findOne(id);
}
```

`ParseUUIDPipe` 可以解析字符串并验证是否为UUID

```jsx
@Get(':uuid')
async findOne(@Param('uuid', new ParseUUIDPipe()) uuid: string) {
  return this.catsService.findOne(uuid);
}
```

自定义管道

`PipeTransform<T, R>` 是每个管道必须要实现的泛型接口。泛型 `T` 表明输入的 `value` 的类型，`R` 表明 `transfrom()` 方法的返回类型

为实现 `PipeTransfrom`，每个管道必须声明 `transfrom()` 方法。该方法有两个参数：

- `value`
- `metadata`

`value` 参数是当前处理的方法参数(在被路由处理程序方法接收之前)，`metadata` 是当前处理的方法参数的元数据。元数据对象具有以下属性：

```jsx
import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';

@Injectable()
export class ValidationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
//这个pipe实际上什么也没做 就是直接返回了
    return value;
  }
}
```

[Joi](https://github.com/sideway/joi) 库允许使用可读的 API 以直接的方式创建 schema，让我们构建一个基于 Joi schema 的验证管道。

```jsx
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';
import { ObjectSchema } from 'joi';

@Injectable()
export class JoiValidationPipe implements PipeTransform {
  constructor(private schema: ObjectSchema) {}

  transform(value: any, metadata: ArgumentMetadata) {
    const { error } = this.schema.validate(value);
    if (error) {
      throw new BadRequestException('Validation failed');
    }
    return value;
  }
}
```

绑定管道 我们用 `@UsePipes()` 装饰器来完成。代码如下:

```jsx
@Post()
@UsePipes(new JoiValidationPipe(createCatSchema))
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
```

类验证器

```jsx
import { IsString, IsInt } from 'class-validator';

export class CreateCatDto {
  @IsString()
  name: string;

  @IsInt()
  age: number;

  @IsString()
  breed: string;
}
```

Nest 支持**同步**和**异步**管道。这样做的原因是因为有些 `class-validator` 的验证是[可以异步的](https://github.com/typestack/class-validator#custom-validation-classes) 你会发现 `transform()` 函数是 `异步` 的

```jsx
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';
import { validate } from 'class-validator';
import { plainToInstance } from 'class-transformer';

@Injectable()
export class ValidationPipe implements PipeTransform<any> {
  //使用解构赋值提取 metatype 字段
  async transform(value: any, { metatype }: ArgumentMetadata) {
    if (!metatype || !this.toValidate(metatype)) {
      return value;
    }
    const object = plainToInstance(metatype, value);//将普通的 JavaScript 参数对象转换为可验证的类型对象。
    const errors = await validate(object);
    if (errors.length > 0) {
      throw new BadRequestException('Validation failed');
    }
    return value;
  }

 //当正在处理的参数是原生 JavaScript 类型时，它负责绕过验证步骤
  private toValidate(metatype: Function): boolean {
    const types: Function[] = [String, Boolean, Number, Array, Object];
    return !types.includes(metatype);
  }
}
```

全局管道

```jsx
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(3000);
}
bootstrap();
```

从任何模块外部注册的全局管道（即使用了 `useGlobalPipes()`， 如上例所示）无法注入依赖，因为它们不属于任何模块。为了解决这个问题，可以使用以下方式

```jsx
import { Module } from '@nestjs/common';
import { APP_PIPE } from '@nestjs/core';

@Module({
  providers: [
    {
      provide: APP_PIPE,
      useClass: ValidationPipe
    }
  ]
})
export class AppModule {}
```

写在provider里面，就会被容器管理了

数据转换

验证不是管道唯一的用处。在本章的开始部分，我已经提到管道也可以将输入数据**转换**为所需的输出

例子

按 ID 从数据库中选择一个现有的**用户实体**。

提供默认值

`Parse*` 管道期望参数值是被定义的。当接收到 `null` 或者 `undefined` 值时，它们会抛出异常。为了允许端点处理丢失的查询字符串参数值，我们必须在 `Parse*` 管道对这些值进行操作之前注入默认值。`DefaultValuePipe` 提供了这种能力。只需在相关 `Parse*` 管道之前的 `@Query()` 装饰器中实例化 `DefaultValuePipe`

```jsx
@Get()
async findAll(
  @Query('activeOnly', new DefaultValuePipe(false), ParseBoolPipe) activeOnly: boolean,
  @Query('page', new DefaultValuePipe(0), ParseIntPipe) page: number,
) {
  return this.catsService.findAll({ activeOnly, page });
}
```