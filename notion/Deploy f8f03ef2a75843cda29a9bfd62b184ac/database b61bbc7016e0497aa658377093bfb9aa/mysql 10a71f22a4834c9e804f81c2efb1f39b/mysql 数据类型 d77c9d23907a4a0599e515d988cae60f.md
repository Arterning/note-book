# mysql 数据类型

# Basic

MySQL 有以下常见的字段类型：

数字类型：

INT: 整数，取值范围为 -2147483648 到 2147483647。
BIGINT: 大整数，取值范围为 -9223372036854775808 到 9223372036854775807。
SMALLINT: 小整数，取值范围为 -32768 到 32767。
TINYINT: 微小整数，取值范围为 -128 到 127。
DECIMAL: 十进制数，精确小数。
FLOAT: 单精度浮点数。
DOUBLE: 双精度浮点数。
字符串类型：

CHAR: 定长字符串，固定长度为 0 到 255 个字符。
VARCHAR: 变长字符串，长度为 0 到 65,535 个字符。
TEXT: 可存储大量文本，长度为 0 到 2^32 - 1 个字符。
BLOB: 二进制大对象，长度为 0 到 2^32 - 1 个字符。
日期和时间类型：

DATE: 日期，格式为 YYYY-MM-DD。
TIME: 时间，格式为 HH:MM:SS。
DATETIME: 日期和时间，格式为 YYYY-MM-DD HH:MM:SS。
YEAR: 年份，格式为 YYYY。
TIMESTAMP: 时间戳，格式为 YYYY-MM-DD HH:MM:SS。
其他类型：

ENUM: 枚举类型，可以存储固定的字符串列表。
SET: 集合类型，可以存储多个

# 如果是主键 使用int还是bigint，哪个好？

一般来说，如果是主键，使用 bigint 更好。

因为 int 的取值范围是 -2147483648 到 2147483647，而 bigint 的取值范围是 -9223372036854775808 到 9223372036854775807，这意味着 bigint 可以存储更大的整数，并且不会出现数据溢出的问题。

此外，如果你预计你的数据表中可能会存在大量数据，使用 bigint 作为主键可以确保主键值永远不会溢出。

因此，如果是主键，建议使用 bigint。

# datetime和timestamp有什么区别吗？

Datetime 和 Timestamp 在 MySQL 中都是用来存储日期和时间的数据类型，但是它们有一些重要的区别：

存储范围：Datetime 的取值范围是 '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59'，而 Timestamp 的取值范围是 '1970-01-01 00:00:01' UTC 到 '2038-01-19 03:14:07' UTC。

精度：Datetime 精确到秒，而 Timestamp 精确到微秒。

数据自动更新：如果将一个 Timestamp 列定义为自动更新，则每次对该列的更新操作都会更新其值，因此它可以用来记录数据的更新时间。而 Datetime 列并不会自动更新。

因此，如果你需要记录一个具体的日期和时间，建议使用 Datetime；如果需要记录时间戳（即数据的更新时间），建议使用 Timestamp。

# char 和 varchar的区别是什么？

Char 和 Varchar 是 MySQL 中用来存储字符串数据类型的两种数据类型。下面是它们的主要区别：

存储空间：Char 是定长字符串数据类型，即不管实际存储的字符串长度多少，都会占用固定的空间；Varchar 是变长字符串数据类型，即实际占用的空间与存储的字符串长度成正比。

性能：Varchar 的存储效率更高，因为它只会占用实际需要的空间；Char 的存储效率较低，因为它占用的空间可能远大于实际需要的空间。

排序和比较：由于 Char 是定长字符串数据类型，在排序和比较字符串时速度更快；而 Varchar 由于是变长字符串数据类型，在排序和比较字符串时速度较慢。

因此，如果你需要存储固定长度的字符串数据，建议使用 Char；如果需要存储可变长度的字符串数据，建议使用 Varchar。

# datetime(3) 的含义

DATETIME(3) 表示的是 MySQL 中的一种 DATETIME 数据类型，其中的 (3) 代表的是精度，即该数据类型能够精确到毫秒级别。因此，使用 DATETIME(3) 可以在存储日期和时间时同时精确到毫秒级别。

# MySQL 中主键自增策略

MySQL 中主键自增策略有以下几种：

AUTO_INCREMENT：MySQL 支持在创建表时定义某一列为自增主键，在插入新数据时，该列会自动增加，不需要人工干预。
UUID：UUID 是 Universally Unique Identifier 的缩写，可以用来生成唯一的标识符。MySQL 也支持使用 UUID 作为主键，以保证数据的唯一性。
自定义自增：如果不使用 AUTO_INCREMENT，也可以通过使用存储过程或触发器来自定义自增策略。
以上是 MySQL 中常见的主键自增策略，选择那种策略要根据实际需求进行决策。

如果你想使用 UUID 作为主键，可以通过以下步骤定义表：

创建一个 CHAR(36) 类型的字段用于存储 UUID：

```
 CREATE TABLE table_name (
    id CHAR(36) NOT NULL,
    ...
    PRIMARY KEY (id)
);

```

在插入数据时使用 UUID() 函数生成 UUID 并保存到该字段中：

```
INSERT INTO table_name (id, ...) VALUES (UUID(), ...);

```

请注意，在不同的 MySQL 版本中，UUID() 函数的用法可能略有差别，请确保使用正确的版本。

一般来说，使用 CHAR(36) 存储 UUID 是因为 UUID 通常是 36 个字符长，包含 8 个 - 分隔符，所以需要 36 个字符的存储空间。例如，一个标准的 UUID 的格式可能是：a1b2c3d4-e5f6-g7h8-i9j0-k1l2m3n4o5p6。

使用 CHAR(36) 存储 UUID 可以方便地保证 UUID 在存储和使用过程中的唯一性，同时可以避免在比较 UUID 时出现类型不匹配的问题。如果使用其他类型存储 UUID，可能会出现精度丢失等问题。

# UID相比自增有什么特点和优势吗？如果自增策略溢出会怎么样？UUID有溢出的可能吗？

UUID 与自增主键相比具有以下特点和优势：

全球唯一性：UUID 是基于全球唯一的算法生成的，因此可以保证全球范围内的唯一性。

分布式数据库：UUID 适用于分布式数据库环境，因为它可以避免因为同步数据库导致的主键冲突。

生成速度：UUID 可以在客户端或应用程序生成，因此不需要与数据库进行通信，生成速度快。

编码长度：UUID 编码长度是固定的，并且不存在溢出的情况。

自增主键如果溢出，将导致数据库出现错误，数据库将无法继续运行。此外，由于自增主键的生成需要与数据库通信，因此生成速度较慢。

UUID 不存在溢出的可能，因为它是通过算法生成的，不受数据库限制。