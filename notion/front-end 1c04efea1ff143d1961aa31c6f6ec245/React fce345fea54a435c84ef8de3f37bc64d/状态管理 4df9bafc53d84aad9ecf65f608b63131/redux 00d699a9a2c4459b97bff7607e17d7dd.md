# redux

## 

## 为什么不直接修改state数据，而是拷贝数据

- redux 单一数据源，时间回溯
- combineReducers的源码：每次reducer返回新的state会跟旧的state做===对比，如果false认为store改变，从而触发页面重绘，如果true，则认为不变，不会触发重绘。所以reducer返回新的state是为了通知redux让页面重绘。

```tsx
var hasChanged = false
    var nextState = {}
    for (var i = 0; i < finalReducerKeys.length; i++) {
      var key = finalReducerKeys[i]
      var reducer = finalReducers[key]
      var previousStateForKey = state[key]
      var nextStateForKey = reducer(previousStateForKey, action)
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(key, action)
        throw new Error(errorMessage)
      }
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    return hasChanged ? nextState : state
```

```jsx
// 表示加1的action
export const ADD_NUMBER= data => (
  type:'ADD',
	data
)

// 表示减1的action
export const SUB_NUMBER=(
  type:'SUB',
	data
)
```

```jsx
const initState = 0 //初始化状态
// 处理action的reducer
const reducer = (state=initState ,action)=>{
	const {type,data} = action
  switch (type) {
    case 'ADD':
      return state+data
    case 'SUB':
      return state-data
    default:
      return state
  }
}

export default reducer

```

```jsx
import { createStore } from 'redux'
import reducer from './reducer/number'

// 通过createStore函数创建store，传入参数中第一个是reducer，第二个是初始的state值（可省略）
const store = createStore(reducer,0)
export default store

```

```jsx
import React, { Component } from 'react'
//引入store，用于获取redux中保存状态
import store from '../../redux/store'

export default class Count extends Component {

	state = {carName:'奔驰c63'}

	/* componentDidMount(){
		//检测redux中状态的变化，只要变化，就调用render
		store.subscribe(()=>{
			this.setState({})
		})
	} */

	//加法
	increment = ()=>{
		const {value} = this.selectNumber
		store.dispatch({type:'increment',data:value*1})
	}

	//减法
	decrement = ()=>{
		const {value} = this.selectNumber
		store.dispatch({type:'decrement',data:value*1})
	}

	//奇数再加
	incrementIfOdd = ()=>{
		const {value} = this.selectNumber
		const count = store.getState()
		if(count % 2 !== 0){
			store.dispatch({type:'increment',data:value*1})
		}
	}

	//异步加
	incrementAsync = ()=>{
		const {value} = this.selectNumber
		setTimeout(()=>{
			store.dispatch({type:'increment',data:value*1})
		},500)
	}

	render() {
		return (
			<div>
				<h1>当前求和为：{store.getState()}</h1>
				<select ref={c => this.selectNumber = c}>
					<option value="1">1</option>
					<option value="2">2</option>
					<option value="3">3</option>
				</select>&nbsp;
				<button onClick={this.increment}>+</button>&nbsp;
				<button onClick={this.decrement}>-</button>&nbsp;
				<button onClick={this.incrementIfOdd}>当前求和为奇数再加</button>&nbsp;
				<button onClick={this.incrementAsync}>异步加</button>&nbsp;
			</div>
		)
	}
}
```

要支持异步action的话，store.js需要这样写

```jsx
/* 
	该文件专门用于暴露一个store对象，整个应用只有一个store对象
*/

//引入createStore，专门用于创建redux中最为核心的store对象
import {createStore,applyMiddleware} from 'redux'
//引入为Count组件服务的reducer
import countReducer from './count_reducer'
//引入redux-thunk，用于支持异步action
import thunk from 'redux-thunk'
//暴露store
export default createStore(countReducer,applyMiddleware(thunk))
```

## react-redux 使用

```jsx
//引入Count的UI组件
import CountUI from '../../components/Count'
//引入action
import {
	createIncrementAction,
	createDecrementAction,
	createIncrementAsyncAction
} from '../../redux/count_action'

//引入connect用于连接UI组件与redux
import {connect} from 'react-redux'

/* 
	1.mapStateToProps函数返回的是一个对象；
	2.返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value
	3.mapStateToProps用于传递状态
*/
function mapStateToProps(state){
	return {count:state}
}

/* 
	1.mapDispatchToProps函数返回的是一个对象；
	2.返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value
	3.mapDispatchToProps用于传递操作状态的方法
*/
function mapDispatchToProps(dispatch){
	return {
		add:number => dispatch(createIncrementAction(number)),
		sub:number => dispatch(createDecrementAction(number)),
		addSync:(number,time) => dispatch(createIncrementAsyncAction(number,time)),
	}
}

//使用connect()()创建并暴露一个Count的容器组件
export default connect(mapStateToProps,mapDispatchToProps)(CountUI)
```

UI 组件

```jsx
import React, { Component } from 'react'
/**
 * 这里引申出一个重要概念
 * UI组件和容器组件
 * 这里CountUI是UI组件
 * 外面哪个是容器组件
 */
export default class Count extends Component {

	state = {carName:'奔驰c63'}

	//加法
	increment = ()=>{
		const {value} = this.selectNumber
		this.props.add(value*1)
	}
	//减法
	decrement = ()=>{
		const {value} = this.selectNumber
		this.props.sub(value*1)
	}
	//奇数再加
	incrementIfOdd = ()=>{
		const {value} = this.selectNumber
		if(this.props.count % 2 !== 0){
			this.props.add(value*1)
		}
	}
	//异步加
	incrementAsync = ()=>{
		const {value} = this.selectNumber
		this.props.addSync(value*1,500)
	}

	render() {
		//console.log('UI组件接收到的props是',this.props);
		return (
			<div>
				<h1>当前求和为：{this.props.count}</h1>
				<select ref={c => this.selectNumber = c}>
					<option value="1">1</option>
					<option value="2">2</option>
					<option value="3">3</option>
				</select>&nbsp;
				<button onClick={this.increment}>+</button>&nbsp;
				<button onClick={this.decrement}>-</button>&nbsp;
				<button onClick={this.incrementIfOdd}>当前求和为奇数再加</button>&nbsp;
				<button onClick={this.incrementAsync}>异步加</button>&nbsp;
			</div>
		)
	}
}
```

可以继续优化将2个组件合并为一个

```jsx
import React, { Component } from 'react'
//引入action
import {
	createIncrementAction,
	createDecrementAction,
	createIncrementAsyncAction
} from '../../redux/count_action'
//引入connect用于连接UI组件与redux
import {connect} from 'react-redux'

//定义UI组件
class Count extends Component {

	state = {carName:'奔驰c63'}

	//加法
	increment = ()=>{
		const {value} = this.selectNumber
		this.props.jia(value*1)
	}
	//减法
	decrement = ()=>{
		const {value} = this.selectNumber
		this.props.jian(value*1)
	}
	//奇数再加
	incrementIfOdd = ()=>{
		const {value} = this.selectNumber
		if(this.props.count % 2 !== 0){
			this.props.jia(value*1)
		}
	}
	//异步加
	incrementAsync = ()=>{
		const {value} = this.selectNumber
		this.props.jiaAsync(value*1,500)
	}

	render() {
		//console.log('UI组件接收到的props是',this.props);
		return (
			<div>
				<h1>当前求和为：{this.props.count}</h1>
				<select ref={c => this.selectNumber = c}>
					<option value="1">1</option>
					<option value="2">2</option>
					<option value="3">3</option>
				</select>&nbsp;
				<button onClick={this.increment}>+</button>&nbsp;
				<button onClick={this.decrement}>-</button>&nbsp;
				<button onClick={this.incrementIfOdd}>当前求和为奇数再加</button>&nbsp;
				<button onClick={this.incrementAsync}>异步加</button>&nbsp;
			</div>
		)
	}
}

const mapStateToProps = state => ({count:state});
const mapDispatchToProps = dispatch => ({
	jia:number => dispatch(createIncrementAction(number)),
	jian:number => dispatch(createDecrementAction(number)),
	jiaAsync:(number,time) => dispatch(createIncrementAsyncAction(number,time)),
});

//使用connect()()创建并暴露一个Count的容器组件
export default connect(
	mapStateToProps,
	mapDispatchToProps
)(Count)

/* 

const mapDispatchToProps = dispatch => ({
	jia:number => dispatch(createIncrementAction(number)),
	jian:number => dispatch(createDecrementAction(number)),
	jiaAsync:(number,time) => dispatch(createIncrementAsyncAction(number,time)),
}) 

可以简写成如下形式

const mapDispatchToProps = {
	jia:createIncrementAction,
	jian:createDecrementAction,
	jiaAsync:createIncrementAsyncAction,
};

*/
```

[仿照Vuex的风格编写](redux%2000d699a9a2c4459b97bff7607e17d7dd/%E4%BB%BF%E7%85%A7Vuex%E7%9A%84%E9%A3%8E%E6%A0%BC%E7%BC%96%E5%86%99%200f41bf689a0b403a9167893607ba8175.md)