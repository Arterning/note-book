# React Query

## **从在react中后端请求数据开始说起**

在日常的开发中，免不了请求后端接口。在请求接口时，经常会涉及到以下处理

- 加载状态
- 后端返回数据存储
- 如果接口有报错信息，展示报错信息
- 刷新数据
- 等等

```jsx
import * as React from 'react';

export default function App() {
  // 存储 后端返回数据
  const [zen, setZen] = React.useState('');
  // 存储 加载状态
  const [isLoading, setIsLoading] = React.useState(false);
  // 存储 是否请求成功
  const [isError, setIsError] = React.useState(false);
  // 存储 后端返回的错误数据
  const [errorMessage, setErrorMessage] = React.useState('');

  const fetchData = () => {
    // 开始获取数据，将isLoading置为true
    setIsLoading(true);

    fetch('https://api.github.com/zen')
      .then(async (response) => {
        // 如果请求返回status不为200 则抛出后端错误
        if (response.status !== 200) {
          const { message } = await response.json();

          throw new Error(message);
        }

        return response.text();
      })
      .then((text: string) => {
        // 请求完成将isLoading置为false
        setIsLoading(false);
        // 接口请求成功，将isError置为false
        setIsError(false);
        // 存储后端返回的数据
        setZen(text);
      })
      .catch((error) => {
        // 请求完成将isLoading置为false
        setIsLoading(false);
        // 接口请求错误，将isError置为true
        setIsError(true);
        // 存储后端返回的错误数据
        setErrorMessage(error.message);
      });
  };

  React.useEffect(() => {
    // 初始化请求数据
    fetchData();
  }, []);

  return (
    <div>
      <h1>Zen from Github</h1>
      <p>{isLoading ? '加载中...' : isError ? errorMessage : zen}</p>
      {!isLoading && (
        <button onClick={fetchData}>{isError ? '重试' : '刷新'}</button>
      )}
    </div>
  );
}
```

该例子仅仅是请求一个接口，假如是一个真实的项目，铁定不止这一个请求，因此我们将要写大量重复代码，来满足业务需求（内心os：其实是代码写的太多影响效率，不能早下班(￢_￢)，而且维护起来成本高）

此时引入react-query可以减少与请求接口相关的代码，上面的例子使用react-query重写如下：

```jsx
import * as React from 'react';
import { useQuery } from 'react-query';

const fetchData = () => {
  return fetch('https://api.github.com/zen').then(async (response) => {
    if (response.status !== 200) {
      const { message } = await response.json();
      throw new Error(message);
    }
    return response.text();
  });
};

export default function App() {
  const zenQuery = useQuery(['zen'], fetchData); // ①
  return (
    <div>
      <h1>Zen from Github</h1>
      <p>
        {zenQuery.isLoading || zenQuery.isFetching
          ? '加载中...'
          : zenQuery.isError
          ? zenQuery.error?.message
          : data}
      </p>
      {!zenQuery.isLoading && !zenQuery.isFetching && (
        <button
          onClick={() => {
            zenQuery.refetch();
          }}
        >
          {zenQuery.isError ? '重试' : '刷新'}
        </button>
      )}
    </div>
  );
}
```

不需要写useState来管理因为请求接口带来的额外状态（如果使用react-redux、mobx等状态管理库，同样会遇到类似的问题），同样也不需要在`useEffect(() => {}, [])`中初始化调用接口，react-query会帮我们处理。

## **查询键(Query Keys)及查询函数(Query Functions)**

什么是查询键(Query Keys)及查询函数(Query Functions)？

在大家日常开发的过程中，请求后端数据时：

- 会先写一个函数来请求后端接口的数据(如上面例子①中的`fetchData`函数)
- 接着指定一个变量(如上面例子①中的`zen`)来存储相关后端返回的数据，每个接口的变量针对不同的接口会起不同的名字，来标识不同的数据。

那么在react-query中如何区分不同的接口获取的不同数据呢？

```jsx
const zenQuery = useQuery(['zen'], fetchData);
```

- 其中`['zen']` 就是react-query的查询键，react-query通过不同的查询键来标识(映射)不同接口(或是同一接口不同参数请求)返回的数据。在`react-query@4`中，查询键必须是数组。
- 而`fetchData`就是我们请求后端接口的函数，也就是查询函数。

## ****写查询键的一些小建议****

还是以github的接口为例，如果你想获取到github中某个仓库的issue列表，你可以这样调用接口

```jsx
https://api.github.com/repos/{owner}/{repo}/issues
```

以这个获取仓库issue列表接口为例，可以这样写查询键

```jsx
['issues', owner, repo]
```

在这个查询键中我们遵循了一个原则：从通用到特殊

首先我们获取的数据类型是issue，我们需要在数组的开头放一个字符串来标识数据类型，因此第一个参数我们设定为`issues`。在github中有许多仓库，这些仓库通常以用户作为第一级标识，仓库名是第二级标识，因此第二个和第三个参数依次是`owner`和`repo`。

使用变量作为查询键的元素时，当变量的值变化后，react-query将会重新调用`fetchData`方法，获取新的数据，并缓存到对应变量值为key的缓存中。这一点非常有用

```jsx
import * as React from 'react';
import { useQuery } from 'react-query';

const fetchData = ({ queryKey }) => {
  const [, owner, repo] = queryKey;

  return fetch(`https://api.github.com/repos/${owner}/${repo}/issues`, {
    headers: {
      Authorization: '',
    },
  }).then(async (response) => {
    // 如果请求返回status不为200 则抛出后端错误
    if (response.status !== 200) {
      const { message } = await response.json();

      throw new Error(message);
    }

    return response.json();
  });
};

export default function App() {
  const [inputOwner, setInputOwner] = React.useState('facebook');
  const [inputRepo, setInputRepo] = React.useState('react');
  const [queryKey, setQueryKey] = React.useState([inputOwner, inputRepo]);
  const issueQuery = useQuery(['issues', ...queryKey], fetchData);

  return (
    <div>
      <span>仓库：</span>
      <input
        name={'owner'}
        value={inputOwner}
        onChange={(e) => setInputOwner(e.target.value)}
      />
      /
      <input
        name={'repo'}
        value={inputRepo}
        onChange={(e) => setInputRepo(e.target.value)}
      />
      <button
        onClick={() => {
          setQueryKey([inputOwner, inputRepo]);
        }}
      >
        查看最新issue信息
      </button>
      <div>
        <h1>
          仓库{queryKey[0]}/{queryKey[1]}最新一条issue信息
        </h1>
        <p>
          {issueQuery.isLoading
            ? '加载中...'
            : issueQuery.isError
            ? issueQuery.message
            : JSON.stringify(issueQuery.data[0])}
        </p>
      </div>
    </div>
  );
}
```

在这个例子中，当查询键变量的值变化后，react-query将会自动请求变化后对应的数据，并且在查询函数传入的参数中，我们也可以拿到调用查询函数时查询键的值。

## ****查询键的值不能重复，需要保持唯一****

在react-query中，如果这么做同样会遇到这样的问题 请求用户数据

```jsx
const usersQuery = useQuery(
  [userId],
  fetchUsers
);
```

请求商品数据

```jsx
const productsQuery = useQuery(
  [productId],
  fetchProducts
);
```

如果`userId`与`productId`相同时，后面请求的数据会覆盖前面请求的数据！解决这个问题的办法是：可以在数组的第一个元素中，放一个字符串来标识当前的数据类型（可以参照笔者之前提到的设计查询键的小建议中的内容），就可以解决这个问题。

```jsx
const usersQuery = useQuery(
  ['users', userId],
  fetchUsers
);

const productsQuery = useQuery(
  ['products', productId],
  fetchProducts
);
```

## **查询函数使用小妙招**

相信在之前的介绍里面，可能把你的思维禁锢在查询函数只能使用fetch（或者axios之类的库）来调用http接口。 但是实际上，所有的Promise函数，都可以作为查询函数。举个例子，浏览器中异步的API接口——获取当前定位的API，可以封装为一个查询函数。

## ****自定义hook封装react-query的查询请求****

定义一个名为`useGithubIssuesQuery`的钩子

```jsx
import { useQuery } from 'react-query';

const useGithubIssuesQuery = ({ owner, repo }) => {
  const fetchData = ({ queryKey }) => {
    const [, owner, repo] = queryKey;

    return fetch(`https://api.github.com/repos/${owner}/${repo}/issues`, {
      headers: {
        Authorization: '',
      },
    }).then(async (response) => {
      // 如果请求返回status不为200 则抛出后端错误
      if (response.status !== 200) {
        const { message } = await response.json();

        throw new Error(message);
      }

      return response.json();
    });
  };

  return useQuery(['issues', owner, repo], fetchData);
};

export default useGithubIssuesQuery;
```

## 参考

****[react-query手把手教程①-入门react-query](https://segmentfault.com/a/1190000041939135)****