# 箭头函数的this

## this是什么

1.在探讨箭头函数对于this的优化之前，我们先得明白this究竟是什么，以及它是如何使用的。**this是使用call方法调用函数时传递的第一个参数，它可以在函数调用时修改，在函数没有调用的时候，this的值是无法确定。**

```jsx
function test(name) {
    console.log(name)
    console.log(this)
}
test('Jerry')  //调用函数
```

等价于

```jsx
function test(name) {
    console.log(name)
    console.log(this)
}
test.call(undefined, 'Tom')
```

如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）。

所以这里我们打出来的this是Window对象。

2. 对象中函数的调用

```jsx
const obj = {
    name: 'Jerry',
    greet: function() {
        console.log(this.name)
    }
}
obj.greet()  //第一种调用方法
obj.greet.call(obj) //第二种调用方法
```

3. 构造函数中this

构造函数里的this稍微有点特殊，每个构造函数在new之后都会返回一个对象，这个对象就是this，也就是context上下文。

```jsx
function Test() {
    this.name = 'Tom'
}
let p = new Test()
console.log(typeof p)  //object
console.log(p.name)    // Tom
```

4.简单总结一下：函数完整的调用方法是使用call方法，包括test.call(context, name)和obj.greet.call(context,name)，这里的context就是函数调用时的上下文，也就是this，只不过这个this是可以通过call方法来修改的；构造函数稍微特殊一点，它的this直接指向new之后返回的对象；window.setTimeout()和window.setInterval()默认的是this是window对象。

在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的 this 值：

如果该函数是一个构造函数，this 指针指向一个新的对象
在严格模式下的函数调用下，this 指向undefined
如果该函数是一个对象的方法，则它的 this 指针指向这个对象
等等
This被证明是令人厌烦的面向对象风格的编程。

```jsx
function Person() {
  // Person() 构造函数定义 `this`作为它自己的实例。
  this.age = 0;

  setInterval(function growUp() {
    // 在非严格模式，growUp() 函数定义 `this`作为全局对象，
    // 与在 Person() 构造函数中定义的 `this`并不相同。
    this.age++;
  }, 1000);
}

var p = new Person();
```

## 箭头函数的特性

箭头函数的特性一：默认绑定外层this

上面提到：this的值是可以用call方法修改的，而且只有在调用的时候我们才能确定this的值。而当我们使用箭头函数的时候，箭头函数会默认帮我们绑定外层this的值，所以在箭头函数中this的值和外层的this是一样的。

例子

```jsx
const obj = {
	a: function() { console.log(this) }    
}
obj.a()  //打出的是obj对象
```

```jsx
const obj = {
    a: () => {
        console.log(this)
    }
}
[obj.a()  //打出来的是window](%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D%207bb7140cb6994a668aa64f47296ee6af.md),在这个位置，外层的this就是windows
```

```jsx
const obj = {
    a: function() { console.log(this) },
    b: {
    	c: () => {console.log(this)}
	}
}
obj.a()   //没有使用箭头函数打出的是obj
obj.b.c()  //打出的是window对象！！
console.log('end')
```

在使用箭头函数的例子里，因为箭头函数默认不会使用自己的this，而是会和外层的this保持一致，最外层的this就是window对象。

## 下面这个例子比较好理解

箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承 this。因此，在下面的代码中，传递给setInterval的函数内的this与封闭函数中的this值相同：

下面这个例子setInterval中的箭头函数的上一层是Person，因为他上一层有一个函数Person,所以这个外层，指的是函数。

```jsx
function Person(){
	this.age = 0;

	setInterval(() => {
		this.age++; // |this| 正确地指向 p 实例
	}, 1000);
}

var p = new Person();
```

箭头函数的特性二：不能用call方法修改里面的this
这个也很好理解，我们之前一直在说，函数的this可以用call方法来手动指定，而为了减少this的复杂性，箭头函数无法用call方法来指定this。

## 思考

在java中，函数是没有this的，只有构造函数有this

但是在javascript中，函数都有this 这是非常神奇的

因为在js中，函数是一等公民

我们可以通过函数直接构造对象，函数就是这个对象的构造函数，

而不一定是用Class构造对象

```jsx
function Person() {
	this.name = "aaa";
	this.age = 19;
}

Person.prototype.sex = '不知道';
Person.prototype.play = function () {
	console.log("你好，我的名字是${this.name}");
}
```

## 总结

普通函数的this 和java中的this是一样的，就是函数的调用者

**箭头函数没有自己的this指向**，它的this指向上一级作用域的this

```jsx
var name = 'window'; // 其实是window.name = 'window'

var A = {
   name: 'A',
   sayHello: function(){
      console.log(this.name)
   }
}
```

sayHello的当前作用域是A对象

sayHello的上一级作用域就是全局作用域，this是window