
## **前言**

在各种业务场景中,我们总是会需要一些定时进行一些操作,这些操作可能是需要在指定的某个时间点操作,也可能是每过一个固定的时间间隔后进行操作,这就要求我们需要有一个定时调度的逻辑,同时,这种定时操作,既有可能在某一刻数量比较密集,也有可能时间间隔比较密集,这就要考虑定时调度器对性能的影响.

> 如果在业务逻辑中,存在数量较大的定时任务,且每个定时任务都创建一个只属于自己的的调度管理器负责自身的生命周期及周期任务执行, 这就极大的浪费cpu的资源,降低自身性能.时间轮算法是一种调度模型,可以有效地利线程资源来处理批量周期任务,时间轮调度模型将数量巨大的定时任务绑定在单个调度器上,并统一使用这个调度器来管理,触发以及执行任务.这种模型使得大量延时任务,周期任务以及通知任务的管理变得高效.




## **1.时间轮核心**

时间轮算法的核心是,`轮询线程不再是负责遍历所有任务,而只在负责处于其当前时间上的任务`.就像钟表一样,时间轮有一个指针会一直旋转,每转到一个新的时间,就去执行挂在这一时刻下的所有任务,当然,这些任务通常是交给其他线程去做,指针要做的只是继续往下转,不会关心任务的执行进度.

下面,我们就从一个最简单的定时任务来一步步优化,看看时间轮到底是怎么设计出来的



## **2.简单定时器**

这种方式最简单,如果想定期执行一个操作,只需要起一个定时器,设置时间间隔,设置回调函数,让它跑就完了.在定时任务非常少的情况下,这种方式没什么问题.如果定时任务的数目很大,并且都有不同的周期,那就产生了非常多的定时器, 这对系统的`内存`和`cpu`都产生了很大的压力,程序还没开始跑呢,定时器已经满天飞了...



## **3.任务队列**

为了不产生过多的定时器,我们只使用一个定时器,将所有的定时任务放到一个`队列`中,每个定时任务都保存一份自己的定时信息,定时器每隔一个周期轮询一遍队列中的所有任务,如果任务的超时时间已到,则执行该任务,如果超时时间还没到,则将该任务的定时信息减掉一个定时器的时间间隔,等到完全减为0时,该任务就可以被执行了, 这个定时器一直这么执行并轮询下去.假设当前定时任务总数有100个,那定时器每个周期会`遍历`一个100个元素的队列,听上去还可以,那要有1000个的时候,10000个时候,这定时器就太可怜了,像一头老牛



## **4.优化任务队列**

为了解决任务队列中任务太多,一个定时器压力太大的问题,我们继续对其进行优化,既然所有的定时任务都放在一个队列下不太行,那就对定时任务进行分类,将定时周期相同的任务放在同一个定时器下,这样每个定时器的压力就会大大减小,每个定时器只负责自己周期内的任务,不负责其他周期的任务.但是如果每个任务的周期都相同,还是要产生很多定时器,似乎还是无法从根本上解决问题...




## **5.简单时间轮**

这时候时间轮的优势就体现出来了,我们设置一个环状的时间队列,队列上的每一个元素,我们称为一个`槽(slot)`,这个槽所对应的时间在整个时间轮里是唯一的, 根据前面的分析也能知道,槽里面是放任务的,而且肯定不会放一个任务,而是放一个`任务队列`.

对这个环状队列,我们维护一个指针,指针指向的槽,就是已经到达`超时时间`的槽,槽里的任务就要被执行.任务在被插入时间轮的时候,就根据当前时间以及自己的时间周期,确定好了自己会处于时间轮中的哪个槽.等到时间轮指针指到这个槽,任务就被`触发`.

![[Pasted image 20240323095459.png]]



这样,时间轮只需要`定时`的轮询轮上的槽,如果有任务就交给任务处理线程去做,没有就继续轮询,即使总任务有一万个,调度器还是只会轮询这十个槽,而不会去轮询一遍十万个任务.

这就是`单层时间轮`,这个时间轮的所能处理的最大周期是有限的,比如,一个具有10个slot的时间轮,wheel size = 10,每两个槽之间的间隔为1s,这个间隔称为tick,即最小的时间间隔,那么这个时间轮的跨度就是10*1 = 10s,也就是所支持能设置的最大周期为10s,如果一个任务每隔11秒执行一次.

同时,10s这个周期太短了,现在各种系统中不乏周期为成百上千秒的定时任务,,且以1s为分割,`颗粒`太大了,秒级以下的定时任务无法被触发.

如果仅仅是个时间跨度为10s切以秒为tick的时间轮,是基本满足不了大部分场景的,为了满足需求,最简单快速的方法就是加大时间轮跨度来提升周期,降低tick来提高精度,如果时间跨度提升为60s, tick改成10ms,就需要6000个槽来安插任务,这样就可以设置周期更长的任务,可以根据更精细的时间单位（10ms）来执行定时任务

需求满足了,但同时又带来了一些问题.


- 轮询线程遍历效率低下问题：当timescale数量增加，task数量较少时，轮询线程遍历效率下降，比如只有50槽上有task，但是却需要遍历6000个timescale。这违背了我们时间轮算法的初衷：`解决遍历轮询线程遍历效率低下的问题`。
- 内存空间浪费问题：时间尺度密集，任务数量少，大部分时间尺度占用的内存空间没有意义。

如果将时间轮跨度设置为1小时，那么整个时间轮需要60x60x1000/100 = 36000个单位的时间刻度，此时时间轮算法的遍历线程会遇到更大的运行效率低下。

因此简单(单层)时间轮的性能上限很低,一旦精度和时间跨度要求上来,就无法达到期望的目标了.



## **多层时间轮**

在上面的场景下,`多层时间轮`就诞生了,就像我们生活中见过的水表一样,有非常多的小表盘


多层时间轮的概念也非常清晰,将时间轮分为多个,每两个轮之间是`进位`的关系,例如最普遍的秒,分,时.

即:

- 秒级时间轮上,设有60个槽, 每两个槽之间的时间为1s.  
    
- 分钟级时间轮上,设有60s个槽,每两个槽之间的时间为1min  
    
- 小时级时间轮上,设有24个槽,每两个槽之间的时间为1h.


![[Pasted image 20240323095653.png]]


这样,秒级每走60个槽,时间过去一分钟,秒级时间轮归零,分级时间轮走一个槽; 分级时间轮每走过60个槽,时间过去一小时,分级时间轮归零,小时级时间轮走一个槽.

通过三级时间轮,只需要遍历60+60+60 =180个槽,就可以成为一个精度为1s, 周期为60x60x60 = 216000s的定时调度器.

多级时间轮的思想在很多开发中间件中都被应用,例如`Netty`、`Akka`、`Quartz`、`ZooKeeper`、`Kafka`等等.

作为学习Linux上C++开发的必备书籍,《Linux高性能服务器编程》以及《Linux多线程服务端编程：使用muduo C++网络库》两本书中,都介绍到了时间轮定时器,其中第二本书中,作者`陈硕`详细介绍了如果将时间轮应用在经典项目:`muduo C++网络库`中,非常值得参考学习!


![[Pasted image 20240323095721.png]]

































