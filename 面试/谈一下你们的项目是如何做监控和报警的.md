

## 本地环境

本地环境： Yourkit 工具性能优化检查

原理是基于字节码插装技术


## 上一家公司


用的是Prometeus和Grafana监控 用的监控面板是JVM(Micrometer)

每五秒钟指标更新一次


我们当然有告警，遇到过
- 服务启动失败
- 后台日志大量报错
- 导入数据的时候堆内存溢出

告警用的是AlertManager

当我们的性能优化代码上线之后，会在过滤器中进行埋点。检测和统计接口的访问时间

代码如下：

```java
package com.example;

import io.prometheus.client.CollectorRegistry;
import io.prometheus.client.Counter;
import io.prometheus.client.Histogram;
import jakarta.annotation.PostConstruct;
import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import java.io.IOException;

@Component
@Slf4j
public class AccessMetricsFilter implements Filter {

    @Autowired
    private CollectorRegistry collectorRegistry;

    @Value("${spring.application.name}")
    private String applicationName;

    private Counter totalCounter;
    private Counter errorCounter;
    private Histogram responseTime;

    @PostConstruct
    private void init() {
        log.info("初始化counter");

        totalCounter = Counter.build("custom_request_total", "自定义请求次数统计")
                              .labelNames("application", "path")
                              .create();

        errorCounter = Counter.build("custom_request_error", "自定义请求错误次数统计")
                              .labelNames("application", "path")
                              .create();

        responseTime = Histogram.build("custom_response_time", "自定义请求响应时间")
                                .labelNames("application", "path")
                                .create();

        collectorRegistry.register(totalCounter);
        collectorRegistry.register(errorCounter);
        collectorRegistry.register(responseTime);
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        String path = request.getRequestURI();

        Histogram.Timer timer = responseTime.labels(applicationName, path).startTimer();

        try {
            filterChain.doFilter(servletRequest, servletResponse);
        } catch (Exception e) {
            errorCounter.labels(applicationName, path).inc();
            throw e;
        } finally {
            totalCounter.labels(applicationName, path).inc();
            timer.observeDuration();
        }
    }
}
```




## 样本

Prometheus会将所有采集到的样本数据以时间序列（time-series）的方式保存在内存数据库中

在time-series中的每一个点称为一个样本（sample），样本由以下三部分组成：

- 指标(metric)：metric name和描述当前样本特征的labelsets;
    
- 时间戳(timestamp)：一个精确到毫秒的时间戳;
    
- 样本值(value)： 一个float64的浮点型数据表示当前样本的值。


```
http_request_total{status="200", method="GET"}@1434417560938 => 94355
```



## Metrics数据结构

```
custom_response_time_bucket{application="springboot-prometheus",path="/myMethod",le="0.005",} 0.0
custom_response_time_bucket{application="springboot-prometheus",path="/myMethod",le="0.01",} 0.0
custom_response_time_bucket{application="springboot-prometheus",path="/myMethod",le="0.025",} 0.0
```


在形式上，所有的指标(Metric)都通过如下格式标示：

```
<metric name>{<label name>=<label value>, ...} value
```


## 总结

- metric name 相当于table name
- label 给数据打标签
- 时间戳
- value

有点类似key - value 数据库

key = metric name + label + timestamp
value = value




## 访问时间统计PQL

当时我们聚焦的指标就是接口的性能，也就是访问时间。

这样就可以查询出所有的接口性能了，如果我们需要查询有哪些接口访问比较慢，可以用这样的SQL


查询接口响应时间都大于0.5的（也就是小于0.5的为0）

```
custom_response_time_bucket{le="0.5"} == 0
```


查询路径为 `myMethod` 的响应时间
```sql
custom_response_time_bucket{path="/myMethod"}
```


查询过去5分钟的平均响应时间

```
sum by (path) (rate(custom_response_time_sum{application="springboot-prometheus",path!~""}[5m]) / rate(custom_request_total{application="springboot-prometheus",path!~""}[5m]))
```


要查询平均响应时间大于3秒的接口名，您可以使用以下PromQL查询语句：

```
sum by (path) (rate(custom_response_time_sum{application="springboot-prometheus",path!~""}[5m]) / rate(custom_request_total{application="springboot-prometheus",path!~""}[5m])) > 3
```


rate是增长率，不太符合我们的需求


合适的做法应该是

```
接口的总请求时长/接口的总调用次数
```


```
custom_response_time_sum{application="springboot-prometheus",path!~""}
custom_request_total{application="springboot-prometheus",path!~""}
```


查询最近的几条还可以这样

```
topk(10, custom_response_time_sum{application="springboot-prometheus",path!~""})
```


```
sum by (path) (custom_response_time_sum{application="springboot-prometheus",path!~""} / custom_request_total{application="springboot-prometheus",path!~""})
```


总结：

关键点 rate，avg函数，sum by (path)





## 这一家公司

这一家公司因为是新业务，用的比较简陋，是钉钉webhook的方式报警的。

简单来说：就是如果报错，就调用钉钉提供的web hook 接口进行报警

告警内容就是：检测到”xx error"在五分钟内出现了N次。。这种




## Timed注解

貌似没有起到作用。。


## RED方法

RED方法是Weave Cloud在基于Google的“4个黄金指标”的原则下结合Prometheus以及Kubernetes容器实践，细化和总结的方法论，特别适合于云原生应用以及微服务架构应用的监控和度量。主要关注以下三种关键指标：

- (请求)速率：服务每秒接收的请求数。
    
- (请求)错误：每秒失败的请求数。
    
- (请求)耗时：每个请求的耗时。
    

在“4大黄金信号”的原则下，RED方法可以有效的帮助用户衡量云原生以及微服务应用下的用户体验问题。



## 总结

在过滤器中注册Histgram，打上app name和path的标签，然后用PQL查询接口的平均耗时，做性能优化