
## **消息事务（最终一致性）**

消息事务其实就是基于消息中间件的两阶段提交，将本地事务和发消息放在同一个事务里，保证本地操作和发送消息同时成功。


```java

//保证本地操作和发送消息同时成功
trans.begin();

try {

updateDb();

sendMessage();

} catch(dbException | msgException) {

trans.rollback();
}


```



# 分布式事务？

分布式事务有几种解决方案，这里仅讨论MQ如何解决分布式事务。

- 两阶段提交
- 补偿事务
- 本地消息表
- MQ 事务消息

MQ作为解决分布式事务的一种，是如何解决分布式事务问题的，如下图，支付服务完成支付步骤后，往MQ发送一条已支付消息，订单服务收到消息后更改订单状态。

  
  
![[Pasted image 20240327112759.png]]


有人就想说，这没什么区别么，甚至加了一层MQ，导致需要两次调用，更复杂风险更大？

MQ解决分布式事务是这样做的，A服务保证消息发送成功，MQ保证消息不会丢失，B服务保证消息消费成功。会出现以下情况：

- A服务生产消息失败，回滚支付操作，业务回到最初状态，保证了一致性。
- A服务生产消息成功，完成支付操作，MQ宕机，MQ重启后，消息还存在，订单服务消费消息，完成修改订单操作。保证了一致性。
- A服务生产消息成功，MQ良好，订单服务消费消息失败。但是消息还存在，等订单服务重启后继续消费消息，保证了一致性。

以上就是分布式事务中的最终一致性：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。

MQ作为完成最终一致性的一种工具。RocketMQ也有自己的事务消息更简单的解决以上问题。



## 问题

我想问一下可靠消息最终一致性方案中，如果上游服务+8块钱，下游服务-8块钱 但是下游服务金额不足，这种应该怎样处理整个事务的回滚呢。

你这种场景根本就不能用可靠消息最终一致性方案,转账这种强一致性的用2PC的方案

如果对性能有要求使用TCC
