
**「单点登录」**（Single Sign On），简称为 **「SSO」**，是目前比较流行的企业业务整合的解决方案之一。 SSO 的定义是在多个应用系统中，**「用户只需要登录一次」**就可以**「访问所有」**相互信任的应用系统。


# **为什么要实现单点登录**

单点登录的意义在于能够在不同的系统中统一账号、统一登录。用户不必在每个系统中都进行注册、登录，只需要使用一个统一的账号，登录一次，就可以访问所有系统。




从Google 统一登录的服务来看


肯定是调用了他的登录接口

而这个登录接口，肯定需要需要鉴权访问的，也就是appid和appSecret

那么，用户输入用户名和密码，登录到google之后，google返回的是什么呢？



# **什么是单点登录**

我们通过一个例子来说明，假设有一所大学，内部有两个系统，一个是邮箱系统，一个是课表查询系统。现在想实现这样的效果：在邮箱系统中登录一遍，然后此时进入课表系统的网站，无需再次登录，课表网站系统直接跳转到个人课表页面，反之亦然。比较专业的定义如下：

**「单点登录」**（Single Sign On），简称为 **「SSO」**，是目前比较流行的企业业务整合的解决方案之一。 SSO 的定义是在多个应用系统中，**「用户只需要登录一次」**就可以**「访问所有」**相互信任的应用系统。



# **通过 OIDC 协议实现单点登录**

## **创建自己的用户目录**

**「用户目录」**这个词很贴切，你的系统的总用户表就像一本书一样，书的封皮上写着“所有用户”四个字。打开第一页，就是目录，里面列满了用户的名字，翻到对应的页码就能看到这个人的邮箱，手机号，生日信息等等。无论你开发多少个应用，要确保你有一份这些应用所有用户信息的 truth source。所有的注册、认证、注销都要到你的用户目录中进行增加、查询、删除操作。你要做的就是**「创建一个中央数据表，专门用于存储用户信息」**，不论这个用户是来自 A 应用、B 应用还是 C 应用。

## **什么是 OIDC 协议**

OIDC 的全称是 OpenID Connect，是一个基于 OAuth 2.0 的轻量级认证 + 授权协议，是 OAuth 2.0 的超集。它规定了其他应用，例如你开发的应用 A（XX 邮件系统），应用 B（XX 聊天系统），应用 C（XX 文档系统），如何到你的**「中央数据表」**中取出用户数据，约定了交互方式、安全规范等，确保了你的用户能够在访问所有应用时，只需登录一遍，而不是反反复复地输入密码，而且遵循这些规范，你的用户认证环节会很安全。


## **架设自己的 OIDC Provider**

什么是 OIDC Provider 呢？我来举一个例子：你经常见到一些网站的登录页面上有「使用 Github 登录」、「使用 Google 登录」这样的按钮。要想集成这样的功能，你**「要先去 Github 那里注册一个 OAuth App，填写一些资料，然后 Github 分配给你一对 id 和 key。」** 此时 Github 扮演的角色就是 OIDC Provider，你要做的就是把 Github 的这种角色的行为，搬到你自己的服务器来。

在 Github 上面搜索 OIDC Provider 会有很多结果：

JS：[https://github.com/panva/node-oidc-provider](https://link.zhihu.com/?target=https%3A//github.com/panva/node-oidc-provider)

Golang：[https://github.com/dexidp/dex](https://link.zhihu.com/?target=https%3A//github.com/dexidp/dex)

Python：[https://github.com/juanifioren/django-oidc-provider](https://link.zhihu.com/?target=https%3A//github.com/juanifioren/django-oidc-provider)



### **在 OIDC Provider 申请一个 Client**

上一步讲到，Github 会分配给你一对 id 和 key，这一步其实就是你在 Github 申请了一个 Client。那么如何向我们自己的服务器上的 OIDC Provider 申请一对这样的 id 和 key 呢？

以 [node-oidc-provider](https://link.zhihu.com/?target=https%3A//github.com/panva/node-oidc-provider/tree/master/example) 举例，最快的获得一个 Client 的方法就是将 OIDC Client 所需的元数据直接写入 node-oidc-provider 的配置文件里面。


### **修改配置文件**

进入 node-oidc-provider 项目下的 example 文件夹：

```markup
$ cd ./example
```

编辑 ./support/configuration.js ，更改第 16 行的 clients 配置，我们为自己指定了一个 client_id 和一个 client_secret，其中的 grant_types 为授权模式，authorization_code 即授权码模式，redirect_uris 数组是允许的业务回调地址，需要填写 Web App 应用的地址，OIDC Provider 会将临时授权码发送到这个地址，以便后续换取 token。

```js
module.exports = {
  clients: [
    {
      client_id: '1',
      client_secret: '1',
      grant_types: ['refresh_token', 'authorization_code'],
      redirect_uris: ['http://localhost:8080/app1.html', 'http://localhost:8080/app2.html'],
    },
  ],
...
}
```


### **启动 node-oidc-provider**

在 node-oidc-provider/example 文件夹下，运行以下命令来启动我们的 OP：

```markup
$ node express.js
```

到现在，我们的准备工作已经完成了，在讲如何在 Web App 中进行单点登录之前，我们先了解一下 OIDC [授权码](https://www.zhihu.com/search?q=%E6%8E%88%E6%9D%83%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1300271420%7D)模式。刚刚提到的许多术语：**「授权码模式」**、**「业务回调地址」**、**「临时授权码」**，可能这些概念你会感到陌生，下文会详细介绍。




## **OIDC 授权码模式**

以下是 OIDC 授权码模式的交互模式，你的应用和 OP 之间要通过这样的交互方式来获取用户信息。


![[Pasted image 20240317125554.png]]


我们的 OIDC Provider 对外暴露一些接口

### **授权接口**

每次调用这个接口，就像是对 OIDC Provider 喊话：我要登录，如第一步所示。

然后 OIDC Provider 会**「检查当前用户在 OIDC Provider 的登录状态」**，如果是未登录状态，OIDC Provider 会弹出一个登录框，与终端用户确认身份，登录成功后会将一个**「临时授权码」**（一个随机字符串）发到你的应用（**「业务回调地址」**）；如果是已登录状态，OIDC Provider 会将浏览器直接重定向到你的应用（**「业务回调地址」**），并携带**「临时授权码」**（一个随机字符串）。如第二、三步所示。

### **token 接口**

每次调用这个接口，就像是对 OIDC Provider 说：这是我的授权码，给我换一个 access_token。如第四、五步所示。


### **用户信息接口**

每次调用这个接口，就像是对 OIDC Provider 说：这是我的 access_token，给我换一下用户信息。到此用户信息获取完毕。

为什么这么麻烦？直接返回用户信息不行吗？

因为安全，关于 OIDC 协议的安全性，又可以展开很大的篇幅，现在简单解释一下：code 的有效期一般只有十分钟，而且一次使用过后作废。OIDC 协议授权码模式中，只有 code 的传输经过了用户的浏览器，一旦泄露，攻击者很难抢在应用服务器拿这个 code 换 token 之前，先去 OP 使用这个 code 换掉 [token](https://www.zhihu.com/search?q=token&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1300271420%7D)。而如果 access_token 的传输经过浏览器，一般 access_token 的有效期都是一个小时左右，攻击者可以利用 access_token 获取用户的信息，而应用服务器和 OP 也很难察觉到，更不必说去手动撤退了。如果直接传输用户信息，那安全性就更低了。一句话：避免让攻击者偷走用户信息。




## 总结

先获取code  然后通过code获取access_token

然后通过access_token 获取用户信息


![[Pasted image 20240317140008.png]]







## **登录态管理**

到目前为止，看起来还不错，我们已经实现了两个应用之间账号的统一，而且在 App 1 中登录时输入一次密码，在 App 2 中登录，无需再次让用户输入密码进行登录，可以直接返回授权码到业务地址然后完成后续的用户信息获取。

现在我们来考虑一下退出问题

### **只退出 App 1 而不退出 App 2**

这个问题实质上是**「登录态的管理问题」**。我们应该管理**「三个会话」**：User ←→ App 1、User ←→ App 2、User ←→ OP。

当 OP 给 App 1 返回 code 时，App 1 的后端在完成用户信息获取后，应该与浏览器建立会话，也就是说 App 1 与用户需要自己保持一套自己的登录状态，方式上可以通过 App 1 自签的 JWT Token 或 App 1 的 cookie-session。对于 App 2，也是同样的做法。

当用户在 App 1 退出时，App 1 只需清理掉自己的登录状态就完成了退出，而用户访问 App 2 时，仍然和 App 2 存在会话，因此用户在 App 2 是登录状态。


OIDC相当于数据库，当我们的应用从OIDC获取到用户信息之后，我们可以根据这个用户信息，给用户签发JWT token。


也就是在第三步，获取用户信息的时候，我们从OIDC获取用户信息，然后生成一个JWT token 然后返回给用户浏览器。这样就完成了最终的登录。


这个JWT token 实际上就是OIDC 返回的id token !!!!


进一步总结：

id token 是用户访问app用的。
access_token 是app访问OIDC用的。







### **同时退出 App 1 和 App 2**

刚才说到**「单点登录」**，与之相对的就是**「单点登出」**，即用户只需退出一次，就能在所有的应用中退出，变成未登录状态。

最先想到的是这种方式，我们在 OIDC Provider 进行登出。



好吧，其实没有任何效果，因为用户和 App 1 之间的会话依然保持，用户和 App 2 之间的会话同样依然保持，所以用户在 App 1 和 App 2 的状态仍然是登录态。

所以，有没有什么办法在用户从 OIDC Provider 登出之后，App 1 和 App 2 的会话也被切断呢？我们可以通过 OIDC Session Mangement 来解决这个问题。

简单来说，App 1 的前端需要轮询 OP，不断询问 OP：用户在你那还登录着吗？如果答案是否定的，App 1 主动将用户踢下线，并将会话释放掉，让用户重新登录，App 2 也是同样的操作。

![[Pasted image 20240317135624.png]]


## 网关的登录鉴权

基于网关的登录拦截，也差不多，多个微服务就相当于多个应用

而肯定有一个登录中心，那么当用户没有登录（请求头里面没有token) 的时候，网关就会拦截请求

把用户重定向到登录中心，进行登录。

登录中心也是一样，先是获取code ，然后通过code获取token，然后通过token获取用户信息。

登录成功之后，就可以访问所有的微服务了。

这样做的好处在于，网关内的微服务不需再开发一套登录鉴权的代码了。


