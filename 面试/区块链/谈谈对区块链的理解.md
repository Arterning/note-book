

![[Pasted image 20240317091203.png]]

每个块通常包含以下信息：  

- **数据：**这可以是交易数据之类的任何东西。
    
- **哈希值：**这基本上是块的 ID。
    
- **前一个哈希值：**这会跟踪前一个块 ID。现在，你只需要知道我们使用这个值在当前块和前一个块之间形成一个链。我将在本文后面解释为什么这个值很重要。
    
- **时间戳**：这告诉我们区块何时被创建。
    
- **工作量证明**：这是一个数字，显示了找到当前块的哈希值的努力。如果你听说过挖矿，这个值代表机器计算哈希值需要多长时间（以数字的形式）。


总结：
区块链就如同一个链表，每个区块通过记录上一个区块的哈希而连接在一起。
区块包括数据，哈希值，前一个哈希值，时间戳，工作量证明。。


## mine功能

我们来看看 Block 类的最终功能。mine功能。

这个mine函数不断增加，直到proofOfWork帮我们找到一个以我们想要的数字，如0开头的哈希值（我们称之为难度）。难度越高，创建哈希所需的时间就越长。这是因为从哈希输出中找到输入的唯一方法就是，不断尝试不同的输入。

有趣的事实：比特币区块的哈希值需要 18 个零，其区块链网络中的所有计算机大约需要 10 分钟才能创建。

如果您听说过人们谈论挖掘加密货币，这就是它的工作原理。他们投资超级机器来计算新区块的哈希值，并获得一些加密货币作为奖励。




## 防止篡改

**你可能想知道为什么它必须那么复杂？**

想象一下，如果创建哈希既简单又快速，那么存储在区块链中的数据将很容易被更改。因此，哈希值是以如此复杂的方式创建的，因此即使一个块被黑客入侵，也需要永远更新以下所有块。这就是区块链如此安全的原因。


总结：
为什么区块链可以防止篡改，就在于如果篡改了，哈希值就会变化。篡改者必须重新计算每个区块的哈希值，这在现实中是不可能实现的。




```js

const hash = require("crypto-js/sha256");
class Block {
  constructor(previousHash, data) {
    this.data = data;
    this.hash = this.calculateHash();
    this.previousHash = previousHash;
    this.timeStamp = new Date();
    this.proofOfWork = 0;
  }

  calculateHash() {
    return hash(
        this.previousHash + 
        JSON.stringify(this.data) +
        this.timeStamp +
        this.proofOfWork
    ).toString();
  }

  mine(difficulty) {
    while (!this.hash.startsWith("0".repeat(difficulty))) {
      this.proofOfWork++;
      this.hash = this.calculateHash();
    }
  }
}

class Blockchain {
  constructor() {
    let genesisBlock = new Block("0", { isGenesis: true });
    this.chain = [genesisBlock];
  }

  addBlock(data) {
    let lastBlock = this.chain[this.chain.length - 1];
    let newBlock = new Block(lastBlock.hash, data);
    newBlock.mine(2); // find a hash for new block
    this.chain.push(newBlock);
  }

  isValid() {
    for (let i = 1; i < this.chain.length; i++) {
      const currentBlock = this.chain[i];
      const previousBlock = this.chain[i - 1];
      if (currentBlock.hash != currentBlock.calculateHash()) return false;
      if (currentBlock.previousHash != previousBlock.hash) return false;
    }
    return true;
  }
}
```