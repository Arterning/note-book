
1）**它是由一个初值都为零的bit数组和多个哈希函数构成，用来快速判断某个数据是否存在。**

2）**本质就是判断具体数据存不存在一个大的集合中。**

3）布隆过滤器是一种类似set的数据结构，只是统计**结果不太准确**


它也是不保存元素的一个集合，它也**不保存元素的具体内容**，但是**能判定这个元素是否在这个集合中存在**


**2.布隆过滤器的特点**

1）一个元素如果在布隆过滤器里判定结果为**不存在，则一定不存在**  
2）一个元素在布隆过滤器里判定结**果存在，则不一定存在**（原理会在下面解释）  
3）布隆过滤器**可以添加元素，但是不能删除元素**，删除元素会导致**误判率增加。**  
4）误判只会发生在过滤器**没有添加过的元素**，对于已**经添加过的元素**不会发生误判。



**3.布隆过滤器使用场景**

1）解决缓存穿透的问题：

**缓存穿透**是什么：  
一般情况下，我们在查询数据的时候，如果用到redis，那么先去查redis，如果**缓存中没有**，再去查数据库，如果**数据库中也不存在**，那么就发生了**缓存穿透**。

当发生缓存穿透的时候，可能会有**大量的查询直击mysql**，一定程度上会拖垮数据库。

解决方案：  
1.1）**给空key设置一个空value**.  
但是当**大量空key**出来的时候，也相当于查了很多次mysql，也可能会拖垮数据库。

1.2）使用布隆过滤器  
**把已存在的key保存在布隆过滤器中**，相当于redis前面有一层布隆过滤器的保护。  
当出现请求的时候：  
1.2.1）**先去查询布隆过滤器是否存在**（如果布隆过滤器返回为不存在，那是一定不存在。）  
1.2.2）**如果存在，才去redis，甚至mysql查询，如果不存在，直接返回。**

2）黑白名单的问题：  
解决原理同上，**把黑名单全部放入布隆过滤器**，再进行过滤。

3）海量数据查找是否存在的问题都可以用布隆过滤器。（比如现有50亿个电话号码，和10万个电话号码，快速准确地判定号码是否存在。）或者注册的时候判断用户名是否已经被占用。。



**4.布隆过滤器原理**

布隆过滤器使用了**多个Hash函数和一个初始值都为0的bit大型数组构成**。

add：  
比如我们现在有一个对象obj1，**它先用多个hash函数得到多个不同的值**，**再拿数组长度进行对这多个值取模得到多个位置**，**将这几个位置置为1**，就完成了add操作。

query:  
查询的时候，**只要多个哈希函数算出来的下标其中有一位是0就代表这个key不存在，如果都是1，可能是存在，则可能遇上了哈希冲突**（这就是为什么，布隆过滤器，无是一定无，有可能有）。


![[Pasted image 20240311112803.png]]

为什么布隆过滤器不能删除：  
如果布隆过滤器删除了一个元素，就是将某个对象的多个下标置为了0，**就大概率会影响到别的元素**，**因为很可能多个元素共享了某一个下标**，所以删除元素会导致误判率增加。






