

如何分析explain执行计划

explain各个字段代表的意思

- id ：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序
- select_type ：查询类型 或者是 其他操作类型
- table ：正在访问哪个表
- partitions ：匹配的分区
- type ：访问的类型
- possible_keys ：显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到
- key ：实际使用到的索引，如果为NULL，则没有使用索引
- key_len ：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度
- ref ：显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值
- rows ：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数
- filtered ：查询的表行占表的百分比
- Extra ：包含不适合在其它列中显示但十分重要的额外信息



先查看type列，如果出现all关键词，就代表sql执行全表扫描 依次从最优到最差分别为：
system > const > eq_ref > ref > range > index > ALL ，



##  第一种

- `system`

表中只有一行数据，是 `const` 的一种特例。



`const` 表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用`主键`或`唯一索引`的所有字段作为查询条件。

```sql
EXPLAIN SELECT * FROM team t WHERE id = 1;

```



`eq_ref` 用于联表查询的情况，按联表的主键或唯一键联合查询。

当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 `system` 与 `const` 之外最好的 join 方式，常用于使用`主键`或`唯一索引`的所有字段作为连表条件。

```sql
EXPLAIN SELECT * FROM member m, member_detail d WHERE m.no=d.no;
```



`ref` 使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。
比如下面这个team_id 为1 的可能有多条记录

```sql
EXPLAIN SELECT * FROM member m WHERE m.team_id=1;
```




- `index_merge`

当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 `key` 列列出了使用到的索引；`ken_len` 列列出了所使用的索引的长度。

```sql
EXPLAIN SELECT * FROM member WHERE id=1 or team_id=1;
```
  



## 第二种

- `unique_subquery`

替代了 `eq_ref`。在一些使用 `IN` 子查询中，使用唯一索引 ，例如。

```sql
value IN (SELECT primary_key FROM single_table WHERE some_expr)
```


- `index_subquery`

与 `unique_subquery` 类似，在 `IN` 子查询中，使用普通索引，例如：

```sql
value IN (SELECT key_column FROM single_table WHERE some_expr)
```









## 第三种


`range` 索引范围查询，常见于使用 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN()或者like等运算符的查询中。执行计划中的 `key` 列表示哪个索引被使用了，`key_len` 列表示使用的索引的长度。
```sql
EXPLAIN SELECT * FROM member WHERE no>1001;
```





`index` 查询遍历了整棵索引树，与 `ALL` 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。
```sql
EXPLAIN SELECT id FROM member;
```



`ALL` 如果一个查询的`type`是`All`,并且表的数据量很大，那么请解决它！！！
```sql
EXPLAIN SELECT * FROM member;
```



## 总结

一般来说，得保证查询达到 range 级别，最好达到 ref 级别。

再看key列，如果null代表没有使用索引

再看rows列，如果越大，代表需要扫描的行数越多，相应耗时就长

最后看 extra列，是否有影响性能的 Using filesort 或者 Using temporary