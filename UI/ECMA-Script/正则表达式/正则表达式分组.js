/**
 * 除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：
 * ^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：
 * 注意到括号内是正则表达式 括号外并不是正则表达式 所有括号外的-并不需要转义
 */

function base() {
  var re = /^(\d{3})-(\d{3,8})$/;
  var result = re.exec("010-12345"); // ['010-12345', '010', '12345']
  //exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。

  result[0]; //'010-12345'
  result[1]; //'010'
  result[2]; //'12345'
}

/**
 * 来看一个更凶残的例子：
 * 这个正则表达式可以直接识别合法的时间。
 */
function base2() {
  var re =
    /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;
  re.exec("19:05:30"); // ['19:05:30', '19', '05', '30']
}

/**
 * 但是有些时候，用正则表达式也无法做到完全验证，比如识别日期
 * 对于'2-30'，'4-31'这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。
 */
function base3() {
  var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/;
}
