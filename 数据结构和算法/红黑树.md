红黑树是平衡树的一种，他的复杂的定义和规则，最后都是为了保证树的平衡性。

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点（NIL节点）。

4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。


红黑树的调整方式有两种
1. 变色
2. 旋转


```java

Node {
  boolean color;
  E item;
  Node left;
  Node right;
  Node parent;
}

Tree {
  Node root;
  void leftRotate(Node x);
  void rightRotate(Node x);
  void insertAndFixUp(Node x);
  void fixUp();
}
/*
 * 左旋示意图：对节点x进行左旋
 *     p                       p
 *    /                       /
 *   x                       y
 *  / \                     / \
 * lx  y      ----->       x  ry
 *    / \                 / \
 *   ly ry               lx ly
 * 左旋做了三件事：
 * 1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时)
 * 2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)
 * 3. 将y的左子节点设为x，将x的父节点设为y
 * 这个指针绕来绕去的， 感觉很晕， 当做一个黑盒子， 知道他的原理就是操作指针的就行了。 不用每次看都去纠结实现。
 * 重点是在于掌握他这种通过旋转和变色达到树的平衡的思想才是最重要的。
 */
void leftRotate(Node x) {

  //1. 将y的左子节点赋给x的右子节点，并将x赋给y左子节点的父节点(y左子节点非空时)
  Node y = x.right;
  x.right = y.left;

  if (y.left != null) {
      y.left.parent = x;
  }

  //2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)
  y.parent = x.parent;

  if (x.parent == null) {
      this.root = y;
  } else {
    if (x == x.parent.left) {
      x.parent.left = y;
    } else {
      x.parent.right = y;
    }
  }


  //3. 将y的左子节点设为x，将x的父节点设为y
  y.left = x;
  x.parent = y;
}

/*************对红黑树节点y进行右旋操作 ******************/
/*
 * 左旋示意图：对节点y进行右旋
 *        p                   p
 *       /                   /
 *      y                   x
 *     / \                 / \
 *    x  ry   ----->      lx  y
 *   / \                     / \
 * lx  rx                   rx ry
 * 右旋做了三件事：
 * 1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时)
 * 2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右)
 * 3. 将x的右子节点设为y，将y的父节点设为x
 */
void rightRotate(Node x) {
  //1. 将y的左子节点赋给x的右子节点，并将x赋给y左子节点的父节点(y左子节点非空时)
  x = y.left;
  y.left = x.right;
  if (x.right != null) {
      x.right.parent = y;
  }

  //2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)
  if (x.parent == null) {
    this.root = x;
  } else {
    if (y == y.parent.left)
      y.parent.left = x;
    else
      y.parent.right = x;
  }

  //3. 将y的左子节点设为x，将x的父节点设为y
  x.right = y;
  y.parent = x;

}

void insertAndFixUp(Node x) {
    //第一步和二叉树的插入过程是一样的。
    insert(x);
    //第二部是调整。插入后调整即可
    fixUp(this);
}

/*
如果是第一次插入，由于原树为空，所以只会违反红-黑树的规则2，所以只要把根节点涂黑即可；如果插入节点的父节点是黑色的，那不会违背红-黑树的规则，什么也不需要做；但是遇到如下三种情况时，我们就要开始变色和旋转了：

1.插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色的；
2.插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的右子节点；
3.插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点。
下面我们先挨个分析这三种情况都需要如何操作，然后再给出实现代码。

对于情况1：插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色的。此时，肯定存在祖父节点，但是不知道父节点是其左子节点还是右子节点，但是由于对称性，我们只要讨论出一边的情况，另一种情况自然也与之对应。这里考虑父节点是祖父节点的左子节点的情况，如下左图所示
于这种情况，我们要做的操作有：将当前节点(4)的父节点(5)和叔叔节点(8)涂黑，将祖父节点(7)涂红，变成上右图所示的情况。再将当前节点指向其祖父节点，再次从新的当前节点开始算法（具体等下看下面的程序）。这样上右图就变成了情况2了。

对于情况2：插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的右子节点。我们要做的操作有：将当前节点(7)的父节点(2)作为新的节点，以新的当前节点为支点做左旋操作。完成后如左下图所示，这样左下图就变成情况3了。

于情况3：插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点。我们要做的操作有：将当前节点的父节点(7)涂黑，将祖父节点(11)涂红，在祖父节点为支点做右旋操作。最后把根节点涂黑，整个红-黑树重新恢复了平衡，如右上图所示。至此，插入操作完成！

我们可以看出，如果是从情况1开始发生的，必然会走完情况2和3，也就是说这是一整个流程，当然咯，实际中可能不一定会从情况1发生，如果从情况2开始发生，那再走个情况3即可完成调整，如果直接只要调整情况3，那么前两种情况均不需要调整了。故变色和旋转之间的先后关系可以表示为：变色->左旋->右旋。

*/
```
