

## Redis 发布订阅 是订阅 runoobChat 频道。
redis 127.0.0.1:6379> SUBSCRIBE runoobChat


往 runoobChat 频道发送消息
redis 127.0.0.1:6379> PUBLISH runoobChat "Redis PUBLISH test"
redis 127.0.0.1:6379> PUBLISH runoobChat "Learn redis by runoob.com"



## 事务
MULTI 开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务


## Rdis PipeLine
管道（pipeline）可以一次性发送多条命令给服务端，服务端依次处理完完毕后，通过一条响应一次性将结果返回
pipeline是非原子性
事务是原子性的
https://juejin.cn/post/6844904127001001991

## question

https://cloud.tencent.com/developer/article/1814536


Redis 的数据类型？
Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求


Redis 的持久化机制是什么？各自的优缺点？
Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制: 
RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。 
AOF：持久化： 
AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件 
中，当重启Redis会重新将持久化的日志中文件恢复数据。当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复 
AOF是不是类似于binlog
binlog是一个二进制格式的文件，用于记录用户对数据库更新的SQL语句信息，例如更改数据库表和更改内容的SQL语句都会记录到binlog里，但是对库表等内容的查询不会记录。



俩种持久化的优缺点是什么？ 
AOF文件比RDB更新频率高，优先使用AOF还原数据。 
AOF比RDB更大 但是速度慢
RDB性能比AOF好 
如果两个都配了优先加载AOF 
如何选择合适的持久化方式？
最好是两种都用


Rdis的存储极限是系统的可用内存大小
Redis 是单线程的，如何提高多核 CPU 的利用率？
可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个 CPU，你可以考虑一下分片（shard）
Redis的分片机制允许数据拆分存放在不同的Redis实例上，每个Redis实例只包含所有键的子集。可以减轻单台Redis的压力，提升Redis扩展能力和计算能力。如果我们只使用一个Redis实例，当Redis宕机将会直接停止服务，所以我们可以采取分片机制，将原本一台Redis实例维护的数据，改为由多个Redis实例共同维护这部分数据。
https://zhuanlan.zhihu.com/p/367227866


一致性哈希有三大特性：
key哈希结果尽可能分配到不同Redis实例。
当实例增加或移除，需要保护已映射的内容不会重新被分配到新实例上。
对key的哈希应尽量避免重复。



LRU(least recently used)

memcached 与redis 的区别？
redis支持更多数据类型而且支持持久化



如何实现集群中的 session 共享存储？
比较好的方法是使用redis缓存session信息



使用过 Redis 分布式锁么，它是什么回事？
先用setnx拿锁 然后用expire设置一个过期时间防止锁忘记释放
不过一般把这两条指令合成一个原子操作才不会出问题 可以用lua脚本



使用过 Redis 做异步队列么，你是怎么用的？








Redis 最适合的场景？
1、会话缓存（ Session Cache） 
最常用的一种使用 Redis 的情景是会话缓存（ session cache）。用 Redis 缓存会话比其他存储（ 如Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时， 如果用户的购物车信息全部丢失， 大部分人都会不高兴的， 现在， 他们还会这样吗？ 幸运的是， 随着 Redis这些年的改进， 很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台Magento 也提供 Redis 的插件。 

2、全页缓存（ FPC） 
除基本的会话 token 之外， Redis 还提供很简便的 FPC 平台。回到一致性问题， 即使重启了 Redis 实例， 因为有磁盘的持久化， 用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地FPC。 再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。 此外， 对WordPress 的用户来说， Pantheon 有一个非常好的插件 wp-redis， 这个插件能帮助你以最快速度加载你曾浏览过的页面。 

3、队列 
Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作， 这使得 Redis 能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（ 如 Python）对 list 的 push/pop操作。 如果你快速的在 Google 中搜索“ Redis queues”， 你马上就能找到大量的开源项目， 这些项目的目的就是利用 Redis 创建非常好的后端工具， 以满足各种队列需求。例如， Celery 有一个后台就是使用 Redis 作为 broker， 你可以从这里去查看。 

4， 排行榜/计数器 
Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（ Set） 和有序集合（ Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以， 我们要从排序集合中获取到排名最靠前的 10 个用户– 我们称之为“ user_scores”， 我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGEuser_scores 0 10 WITHSCORES Agora Games 就是一个很好的例子， 用Ruby 实现的， 它的排行榜就是使用 Redis 来存储数据的， 你可以在这里看到。 

5、发布/订阅 
最后（ 但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用， 还可作为基于发布/订阅的脚本触发器， 甚至用 Redis 的发布/订阅功能来建立聊天系统！




Redis 提供 6种数据淘汰策略：
volatile-lru：从已设置过期时间的数据集（ server.dbi.expires）中挑选最近最少使用的数据淘汰 
volatile-ttl： 从已设置过期时间的数据集（ server.dbi.expires） 中挑选将要过期的数据淘汰 
volatile-random： 从已设置过期时间的数据集（ server.dbi.expires） 中任意选择数据淘汰

allkeys-lru： 从数据集（ server.dbi.dict） 中挑选最近最少使用的数据淘汰 
allkeys-random： 从数据集（ server.dbi.dict） 中任意选择数据淘汰 
no-enviction（ 驱逐） ： 禁止驱逐数据




Redis 如何做内存优化？
答： 尽可能使用散列表（ hashes）， 散列表（ 是说散列表里面存储的数少） 使用的内存非常小， 所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个用户对象， 不要为这个用户的名称， 姓氏， 邮箱， 密码设置单独的 key,而是应该把这个用户的所有信息存储到一张散列表里面



怎么理解 Redis 事务？
答： 
1） 事务是一个单独的隔离操作： 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中， 不会被其他客户端发送来的命令请求所打断。 
2） 事务是一个原子操作： 事务中的命令要么全部被执行， 要么全部都不执行。 


Pipeline 有什么好处，为什么要用 pipeline？
答：可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有因果相关性。使用redis-benchmark 进行压测的时候可以发现影响 redis 的 QPS 峰值的一个重要因素是 pipeline 批次指令的数目。



是否使用过 Redis 集群，集群的原理是什么？
Redis Sentinal 着眼于高可用， 在 master 宕机时会自动将 slave 提升为master， 继续提供服务。 类似zookeeper
Redis Cluster 着眼于扩展性， 在单个 redis 内存不足时， 使用 Cluster 进行分片存储。 
哨兵主要有两个重要作用：
第一：哨兵节点会以每秒一次的频率对每个 Redis 节点发送PING命令，并通过 Redis 节点的回复来判断其运行状态。
第二：当哨兵监测到主服务器发生故障时，会自动在从节点中选择一台将机器，并其提升为主服务器，然后使用 PubSub 发布订阅模式，通知其他的从节点，修改配置文件，跟随新的主服务器。
哨兵类似于服务注册中心

Redis 的同步机制了解么？
答：Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave， 并同时将后续修改操作记录到内存 buffffer， 待完成后将 rdb 文件全量同步到复制节点， 复制节点接受完成后将 rdb 镜像加载到内存。加载完成后， 再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。 



主（Master）和从（Slave）分别部署在不同的服务器上，当主节点服务器写入数据时，同时也会将数据同步至从节点服务器，通常情况下，主节点负责写入数据，而从节点负责读取数据。


## 缓存穿透 缓存击穿 缓存雪崩

缓存穿透是指数据库原本就没有的数据，请求如入无人之境，直奔数据库

而缓存击穿，则是指数据库有数据，缓存也本应该有数据，但是突然缓存过期了，这层保护屏障被击穿了，请求直奔数据库

缓存雪崩则是指很多缓存同一个时间失效了，流量全部涌入数据库，造成数据库极大的压力。


## 如何保证缓存与数据库双写的一致性

读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，

同时返回请求。
更新的时候，先删除缓存，然后再更新数据库。


先删除缓存，再更新数据库。
如果数据库更新失败了，那么数据库中是旧数据，缓存是空的，那么数据不会不一致。

因为读的时候缓存没有了，所以读了数据库中的旧数据，然后更新到缓存中。


```javascript
cache.invalidate()
db.update()
```
