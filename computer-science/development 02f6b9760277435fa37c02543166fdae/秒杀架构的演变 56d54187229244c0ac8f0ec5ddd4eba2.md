# 秒杀架构的演变

Created time: June 5, 2023 2:24 PM

## **1. 常见场景**

最典型的就是淘宝京东等电商双十一秒杀了，短时间上亿的用户涌入，瞬间流量巨大(高并发)。例如，**200万人准备在凌晨12:00准备抢购一件商品**，但是**商品的数量是有限的100件**，这样**真实能购买到该件商品的用户也只有100人及以下，不能卖超**

但是从业务上来说，秒杀活动是希望更多的人来参与，也就是抢购之前希望有越来越多的人来看购买商品，但是，在抢购时间达到后，用户开始真正下单时，**秒杀的服务器后端却不希望同时有几百万人同时发起抢购请求**

我们都知道服务器的处理资源是有限的，所以出现峰值的时候，很容易导致服务器宕机，用户无法访问的情况出现，这就好比出行的时候存在早高峰和晚高峰的问题，为了解决这个问题，出行就有了错峰限行的解决方案

同理，在线上的秒杀等业务场景，也需要类似的解决方案，需要平安度过同时抢购带来的流量峰值的问题，这就是**流量削峰**的由来

## **2. 流量削峰**

削峰从本质上来说就是更多地延缓用户请求，以及层层过滤用户的访问需求，遵从**最后落地到数据库的请求数要尽量少**的原则

流量削峰主要有三种操作思路(**排队，答题，过滤**)，简单说下

1. **排队**最容易想到的解决方案就是用**消息队列**来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去，在这里，**消息队列**就像**水库**一样，拦蓄上游的洪水，削减进入下游河道的洪峰流量，从而达到减免洪水灾害的目的
2. **答题**目的其实就是延缓请求，起到对请求流量进行削峰的作用，从而让系统能够更好地支持瞬时的流量高峰
3. 前面介绍的排队和答题，要么是在接收请求时做缓冲，要么是减少请求的同时发送，而针对秒杀场景还有一种方法，就是对请求进行**分层过滤**，从而过滤掉一些无效的请求，从Web层接到请求，到缓存，消息队列，最终到数据库这样就像漏斗一样，尽量把数据量和请求量一层一层地过滤和减少了，最终，到漏斗最末端(数据库)的才是有效请求

### **传统方式**

我们首先搭建一个后台服务接口(实现校验库存，扣库存，创建订单)，不做任何限制，使用**JMeter**，模拟**500**个并发线程测试购买**10**个库存的商品，地址: **[1. 传统方式](https://note.dolyw.com/seckill-evolution/01-Tradition-Process.html)**

可以发现**并发事务下会出现错误**，出现**卖超问题**，这是因为同一时间大量线程同时请求校验库存，扣库存，创建订单，这三个操作不在同一个原子，比如，很多线程同时读到库存为**10**，这样都穿过了校验库存的判断，所以出现卖超问题

在这种情况下就引入了**锁**的概念，锁区分为**乐观锁和悲观锁**，悲观锁都是牺牲性能保证数据，所以在这种高并发场景下，一般都是使用**乐观锁**解决

### **使用乐观锁**

我们再搭建一个后台服务接口(实现校验库存，扣库存，创建订单)，但是这次我们需要使用**乐观锁**，这里可以先查看一篇文章: **[MySQL那些锁(opens new window)](http://note.dolyw.com/database/01-MySQL-Lock.html)**

使用**JMeter**，模拟**500**个并发线程测试购买**10**个库存的商品，地址: **[2. 使用乐观锁](https://note.dolyw.com/seckill-evolution/02-Optimistic-Lock.html)**

可以发现乐观锁解决**卖超问题**，多个线程同时在**检查库存**的时候都会拿到当前商品的相同乐观锁版本号，然后在**扣库存**时，如果版本号不对，就会扣减失败，抛出异常结束，这样每个版本号就只能有第一个线程扣库存操作成功，其他相同版本号的线程秒杀失败，就不会存在**卖超问题**了

```java
/**
     * 乐观锁更新扣减库存
     *
     * @param stockDto
     * @return int
     * @throws
     * @author wliduo[i@dolyw.com]
     * @date 2019/11/22 14:14
     */
    @Update("UPDATE t_seckill_stock SET count = count - 1, sale = sale + 1, version = version + 1 " +
            "WHERE id = #{id, jdbcType = INTEGER} AND version = #{version, jdbcType = INTEGER} " +
            "")
    int updateByOptimisticLock(StockDto stockDto);
```

checkStock是第一次查询，同时stockDto返回了版本号

saleStock 是修改，传入了版本号，如果数据库的版本号和传入的版本号不一样，就失败

这就是乐观锁

```java
				// 检查库存
        StockDto stockDto = seckillTraditionService.checkStock(id);
        // 扣库存
        Integer saleCount = seckillTraditionService.saleStock(stockDto);
```

### **使用缓存**

我们继续搭建一个后台服务接口(实现校验库存，扣库存，创建订单)，这次我们引入**缓存**，这里可以先查看一篇文章: **[Redis与数据库一致性(opens new window)](https://note.dolyw.com/cache/00-DataBaseConsistency.html)**

这里我采用的是**先更新数据库再更新缓存**，因为这里**缓存数据计算简单**，只需要进行加减一即可，所以我们直接进行更新缓存

这次主要改造是**检查库存和扣库存**方法，**检查库存**直接去**Redis**获取，不再去查数据库，而在**扣库存**这里本身是使用的乐观锁操作，只有操作成功(扣库存成功)的才需要**更新缓存数据**

使用**JMeter**，模拟**500**个并发线程测试购买**10**个库存的商品，地址: **[3. 使用缓存](https://note.dolyw.com/seckill-evolution/03-Optimistic-Lock-Redis.html)**

我们可以看下使用缓存后**Druid**的监控，地址: **[http://localhost:8080/druid/sql.html(opens new window)](http://localhost:8080/druid/sql.html)**

使用了缓存，可以看到库存查询**SQL**，**只执行了一次，就是缓存预热那执行了一次**，不像之前每次库存都去查数据库

### **使用分布式限流**

我们继续搭建一个后台服务接口(实现校验库存，扣库存，创建订单)，这次我们引入**限流**，这里可以先查看一篇文章: **[高并发下的限流分析](http://note.dolyw.com/distributed/02-Distributed-Limit.html)**

### **使用队列异步下单**

那我们还可以怎么优化提高吞吐量以及性能呢，我们上文所有例子其实都是**同步请求**，完全可以利用**同步转异步来提高性能**，这里我们将下订单的操作进行异步化，利用消息队列来进行解耦，这样可以让 DB 异步执行下单

**每当一个请求通过了限流和库存校验之后就将订单信息发给消息队列，这样一个请求就可以直接返回了，消费程序做下订单的操作，对数据进行入库落地**，因为异步了，所以最终需要采取回调或者是其他提醒的方式提醒用户购买完成

## 总结

关键是要掌握好主要的思路，就是尽可能减轻落在mysql上的流量压力

优化思路就是

使用乐观锁，使用缓存，限流，异步队列

- [参考](https://note.dolyw.com/seckill-evolution/00-Preparation.html#_4-4-%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81)
- [参考](https://note.dolyw.com/study.html)