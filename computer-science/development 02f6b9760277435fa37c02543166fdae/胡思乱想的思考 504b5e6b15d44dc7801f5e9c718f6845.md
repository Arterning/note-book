# 胡思乱想的思考

Created time: January 18, 2023 3:28 PM

左边是中文 右边是英文 这种方式还是不错的

[Babel](https://babeljs.io/)是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。

这意味着，你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持。

前端的东西，其实和后端差不多，对于框架和工具来说就是各种配置

webpack 有配置文件 需要配置

babel 有配置文件 需要配置

eslint 有配置文件 需要配置

就连typescript 编译器 你可以配置。。

当然最好还是不要配置这么多鸟玩意 所以有了脚手架 开箱就用。。

不过网络上很多关于这些方面的文章主要在于如何配置使用的阶段。

真的很垃圾，简直就是在垃圾堆里面找吃的。。。

关于在zooomlion VPN的使用

有了VPN 随时随地都可以开工 确实是方便 不过最好还是不要去做晚上一个电话就让你改bug的事情

安装easy connect

1. 填写服务器地址
2. 填写用户名和密码
3. 自动给我安装了中联vpn 我也不知道咋回事。。

接着在vpn环境下才能够使用vmware 云桌面  这个虚拟主机其实就是vmware虚拟机 不过区别在于他是基于云部署的。你在任何地方都可以用vmware horizon client 连接上去。

## 个人的产品和技术方案

密码管理

这个我曾经花了不少时间来处理

首先最开始使用的是lastpass 

但是第一是安全性不让人放心 第二是登录总是出现一些问题 于是放弃

 调研过vault 界面很好看 但是需要部署服务器

很多时候就是首页一个推荐 你就点进去了 然后环境折腾半天

当初主要是需要在nginx上设置https协议 失败了许多次 最后终于成功生成了证书 在本地生成的 

使用浏览器的时候还是提示不受信任的。

实际上你需要先确认好你的需求

同时支持多端 pc 手机

数据保存在云端 一旦数据保存在云端  你就必须要仔细考虑数据安全问题

如果选择自己搭建服务器 也不是不可以 但是比较麻烦

经过搜索 最后选择了浆果云的web dav 服务 在上面保存keepass文件

比较幸运的是 keepass有很多开源android的实现 可以打开keepass文件

目前用起来 感觉还可以 算是一个比较优秀的解决方案

科学上网

不多说 hystreia 目前感觉非常良好

最近也摸清楚了git命令行设置代理的方式 

日后远程工作 对于git提交代码这方面应该是没有网速的阻碍的了

不过这仍然不算一个非常好的解决方案

对于一些软件 仍然无法翻墙 比如figma

曾经在网上看到过使用clash配置软路由 需要一台限制的电脑作为软路由服务器

clash现在还没配置明白

对于我来说 可以使用付费机场 但是既然我有一台vps服务器了 就干脆自己配置算了

但是令人讨厌的是 ssr和v2ray在之前最后一次使用后 就再也没有在本地连接成功了

真是邪了门了

笔记

notion 云端笔记解决方案 图片解决方案 个人计划解决方案 网页收藏解决方案

typora 本地编辑markdown解决方案

note-book 同步github仓库

沟通和协作工具

slack skype google doc

产品开发

javascript typescript java golang..

对于技术栈的选择可以根据自己口味来

比如数据访问层 对于开发小而美的软件产品来说 

我比较喜欢spring-jpa

nest-js的orm实现也是参考了spring-jpa-data 

所以我觉得如果我可以把这个技术学好

是很有价值的 你可以通过这个技术的掌握触类旁通其他的东西

这就是要优先学习性价比高的东西

而不是胡子眉毛一把抓

个人学习

视频资料 udemy b站

我现在已经无法接受一个产品或者框架动辄几百集十几个小时的视频教程了

太长了 而且废话也是比较多

对于初次接受计算机的学员来说

这种教学方式是必要的

但是对于资深开发者来说

可以缩短时间 直入主题

是否可以考虑这样的方式 先搜视频 结合看官方文档 太长的视频只要看关键部分就可以了

不要被时长吓破了胆！

关于前端后端的一些思考

在蜜獾工作的这三年

主要负责后端工作

你说后端的技术没有变化和更新了 

那当然不是的

后端的技术栈也在不断的更新迭代

比如兴起的微服务架构 云原生的思想

但是同时也注意到一点 也就是对于普通从业者来说 

后端的学习成本是比较高的

个人认为学习成本主要在于服务器资源和分布式环境的配置上

现在的后端服务已经越来越复杂 涉及到诸多的组件 服务 

个人开发者对于维护这样庞大数量的服务器和微服务是难以想象的

但是如果不尝试的话 很多知识和问题只有从实践中才能得到

虽然现在云服务兴起 但是购买云服务的价格也不是一笔小数目

所以综上所述 个人认为后端的学习成本明显高于前端

前端虽然职责相对单一 但是学习成本低 不需要购买服务器

而且发展很快 涌现出来很多优秀框架和开发者

未来可期

所以这段时间花了很大力气学习前端 感觉还是值得的

当然以后我的想法是做一个独立开发者 全栈开发者 

这是对于专业领域的精进和下一份远程工作来说 我希望做前端

## 关于依赖注入的一点思考

nestjs大量吸收了springboot的特性 有依赖注入和装饰器的概念

但是为什么在前端和其他语言中 依赖注入并没有那么强调？

此外 面向切面编程思想有很多实际的场景

只是在不同语境下叫法不一样

比如springboot有filter interceptor aop

nestjs有守卫 拦截器 的概念 其实都是拦截url

这个思想其实都是相通的

## 关于模块化设计的思考

模块化 拆分是架构师的首要思考方向

这一思想体现在各种方面

包括unix的设计哲学 就是每个工具把自己的事情做到最好 然后用管道运算符连接起来

这一思想进而延申到微服务领域

每个微服务现在已经尽可能的简单 只是对数据库进行简单的crud

许多的微服务通过远程调用 一般是http 连接起来 构成系统对外提供服务

单个微服务因为比较简单 他的维护成本就比较低了。

模块化设计是好的，不过也不要过度拆分

如果拆分的粒度非常小 会产生非常多的胶水代码

这种胶水代码虽然没有什么实际逻辑意义 但是却是不可或缺的

比如

a | b | c | d| e | f | g…

产生许多的管道连接符号

比如微服务如果过度拆分 会怎么样？

那么一项服务会产生过多的远程调用 是的 远程调用在这里就相当于胶水代码

那么中间环节就变多了 产生了比较多的http请求 出现问题的几率变大

体现在代码设计中 过度的拆分会导致模块增多 需要写大量的import之类的语句

import也是胶水代码

不过如果代码的设计结构清晰 胶水代码稍微多一点也不会造成什么影响 只要有利于维护就行了。

这种代码最好统一放在一个地方 这样比较好维护。

### 关于代理和Wrapper的思考

在看Jest代码的时候 感受到了代理的重要性

```jsx
expect(app.title).toEqual('shop-cart');
```

app.title 是没有toEqual方法的

expect 返回的是一个代理对象 

这个代理对象上又各种断言方法

toEqual toBe 等等

我猜测基本上junit也是这个原理才对

代理这个概念在网络架构中也很常见

比如我们需要科学上网 简单描述一下就是

proxy(you).connect(google)

你本来是没有访问外网的能力的，给你加一层代理 对网络流量进行一下包装和伪装 这样就可以连接成功了

还有什么反向代理 其实就是后端服务器转发 其实都是很简单的。

## 特点

crud很重要 

但是有自己的特点

1. 网络安全攻防 感兴趣。。
2. UI 美化和动画。。。 感兴趣
3. 网络编程 。。。感兴趣 因为我是科学上网的重要使用者

### 关于对技术的判断力和口味的思考

编程世界有这么一个特点

我姑且称之为先行者理论

早出现的技术有优势

如果早出现的技术可以解决很棘手的问题 同时还能稳定运行 没有太大的缺陷

那么这就是他的先行优势 后来者想要赶超和超越是比较困难的

那么学习这样的技术也是比较有价值的 而不是一顿乱学

基于这一理论思考go语言和rust语言这两个技术新贵 看可以得出什么样的结论

go语言的比较成功的项目应该是docker和kubernets

同时在区块链上也有很多的积累项目

一旦一个项目取得比较大的成功 那么就说明这个技术是可以被广泛大规模应用的

也证明了这个技术的实力 相当于一个信任背书

而rust语言近期已经在linux内核中被采用

众所周知 linus作为linux代码的维护者有着非常挑剔的眼光

rust可以被合入linux代码内核 

说明了很重要的问题 

那就是这个语言确实是非常优秀

另外

也有越来越多的优秀开源项目使用rust实现

## 关于编程语言的核心技术概念

因为现在接触到的语言比较多了 

所以想从更加大的角度去思考各种语言的设计问题

基本逻辑结构都大同小异

if else for loop

内存管理和分配

手动回收内存

自动回收内存 

垃圾收集器 

java 有垃圾回收器 

go 也有

JS引擎有很多种（各个浏览器都不同），其***垃圾回收机制***
在一些细节及优化上略有不同

rust 不需要垃圾回收

强类型系统和弱类型系统其实也是内存管理的两种不同理念

异常处理

我一直觉得java和js中的try catch还凑活

go的错误处理 一直需要判断err ≠ nil 实在是不方便

模块和第三方依赖管理

java public protected private

go 大写就是Public 小写就是Private

Js export 才是Public

进程和线程模型

java 线程状态 。。。

go 天生适合高并发  go routine

nodejs 事件循环 单线程

## 关于个人代码仓库的管理问题

之前一直没有仔细思考过这个问题

现在总结一下这一段时间仓库管理的心得

1. code 仓库负责简单的语言入门和代码片段和知识记录
2. notebook 仓库负责写博客 不要写代码！！ 
3. 各种语言和框架的项目都有自己的root仓库 比如react对应react-example Vue对应vue-example

angular对应angular-things java也有自己的大本营 就是pinda-authority go是go-fast rust还没有现在

1. 对于自己的项目需要做开源 可以单独建一个仓库