# 全局异常处理

基础异常类

`Nest`提供了一个内置的 `HttpException` 类

```jsx
@Get()
async findAll() {
  throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);
}
```

```jsx
import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';
import { Request, Response } from 'express';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const status = exception.getStatus();

    response
      .status(status)
      .json({
        statusCode: status,
        timestamp: new Date().toISOString(),
        path: request.url,
      });
  }
}
```

`ArgumentsHost` 是一个功能强大的实用程序对象 我们使用它来获取对 `Request` 和 `Response` 对象的引用

更加细粒度的控制

```jsx
//方法作用域
@Post()
@UseFilters(new HttpExceptionFilter())
async create(@Body() createCatDto: CreateCatDto) {
  throw new ForbiddenException();
}

...

//控制器作用域
@UseFilters(new HttpExceptionFilter())
export class CatsController {}
```

这里使用了 `@UseFilters()` 装饰器。和 `@Catch()`装饰器类似，它可以使用单个过滤器实例，也可以使用逗号分隔的过滤器实例列表。

全局过滤器用于整个应用程序、每个控制器和每个路由处理程序。

```jsx
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalFilters(new HttpExceptionFilter());
  await app.listen(3000);
}
bootstrap();
```

但是从任何模块外部注册的全局过滤器（使用上面示例中的 `useGlobalFilters()`）不能注入依赖，因为它们不属于任何模块。

异常过滤器的继承

```jsx
import { Catch, ArgumentsHost } from '@nestjs/common';
import { BaseExceptionFilter } from '@nestjs/core';

@Catch()
export class AllExceptionsFilter extends BaseExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    super.catch(exception, host);
  }
}
```