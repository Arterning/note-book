# Graphql

```bash
$ npm i --save @nestjs/graphql graphql-tools graphql apollo-server-express@2.x.x
```

有2种方式

Nest 提供了两种构建 GraphQL 应用程序的方式，**模式优先**和**代码优先**。你可以选择一个适合自己的最佳方案。在 GraphQL 一章中的大部分章节将被分为两个主要部分：一部分采用**代码优先**，另一部分采用**模式优先**。

在**代码优先**的方式中，你将仅使用装饰器和 TypeScript 类来生成相应的 GraphQL schema。如果您更喜欢使用 TypeScript 来工作并想要避免语言语法之间的上下文切换，那这种方式会更有效。

**模式优先**的方式，本质是 GraphQL SDL（模式定义语言）。它以一种与语言无关的方式，基本允许您在不同平台之间共享模式文件。此外，Nest 将根据GraphQL 模式（通过类或接口）自动生成 TypeScript 定义，以减少冗余。

首先导入模块

```bash
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';

@Module({
  imports: [
    GraphQLModule.forRoot({}),
  ],
})
export class ApplicationModule {}
```

当您的应用程序在后台运行时，打开 Web 浏览器并访问： [http://localhost:3000/graphql](http://localhost:3000/graphql) （主机和端口可能因您的配置而异）。你将看到 GraphQL playground

## 模式优先

`typePaths` 属性指示 `GraphQLModule` 应该查找 GraphQL SDL schema 文件的位置

添加 `definitions` 属性即可创建对应于 GraphQL SDL 类型的 TypeScripts 定义（类和接口）

```tsx
GraphQLModule.forRoot({
  typePaths: ['./**/*.graphql'],
  definitions: {
    path: join(process.cwd(), 'src/graphql.ts'),
    outputAs: 'class',
		watch: true,//文件监听模式 当任何 .graphql 文件更改时自动生成类型定义
  },
}),
```

然后运行

```tsx
$ ts-node generate-typings
```

定义Schema

```tsx
type Author {
  id: Int!
  firstName: String
  lastName: String
  posts: [Post]
}

type Post {
  id: Int!
  title: String!
  votes: Int
}

type Query {
  author(id: Int!): Author
}
```

创建Resolver

```tsx
@Resolver('Author')
export class AuthorResolver {
  constructor(
    private readonly authorsService: AuthorsService,
    private readonly postsService: PostsService,
  ) {}

  @Query()
  async author(@Args('id') id: number) {
    return await this.authorsService.findOneById(id);
  }

  @ResolveProperty()
  async posts(@Parent() author) {
    const { id } = author;
    return await this.postsService.findAll({ authorId: id });
  }
}
```

自动生成的TypeScript类是这样的

```tsx
export class Author {
  id: number;
  firstName?: string;
  lastName?: string;
  posts?: Post[];
}

export class Post {
  id: number;
  title: string;
  votes?: number;
}

export abstract class IQuery {
  abstract author(id: number): Author | Promise<Author>;
}
```

我们接着添加Mutation

```tsx
type Author {
  id: Int!
  firstName: String
  lastName: String
  posts: [Post]
}

type Post {
  id: Int!
  title: String
  votes: Int
}

type Query {
  author(id: Int!): Author
}

type Mutation {
  upvotePost(postId: Int!): Post
}
```

```tsx
@Resolver('Author')
export class AuthorResolver {
  constructor(
    private readonly authorsService: AuthorsService,
    private readonly postsService: PostsService,
  ) {}

  @Query('author')
  async getAuthor(@Args('id') id: number) {
    return await this.authorsService.findOneById(id);
  }

  @Mutation()
  async upvotePost(@Args('postId') postId: number) {
    return await this.postsService.upvoteById({ id: postId });
  }

  @ResolveProperty('posts')
  async getPosts(@Parent() { id }) {
    return await this.postsService.findAll({ authorId: id });
  }
}
```

## 代码优先

使用装饰器和 TypeScript 类来生成相应的 GraphQL schema。

`autoSchemaFile` 属性值是您自动生成的 schema 文件将被创建的路径。

按照字典顺序对 schema 进行排序，需设置 `sortSchema` 属性为 `true`

```tsx
GraphQLModule.forRoot({
  autoSchemaFile: join(process.cwd(), 'src/schema.gql'),
	sortSchema: true,
}),
```

```tsx
import { Field, Int, ObjectType } from 'type-graphql';
import { Post } from './post';

@ObjectType()
export class Author {
  @Field(type => Int)
  id: number;

  @Field({ nullable: true })
  firstName?: string;

  @Field({ nullable: true })
  lastName?: string;

  @Field(type => [Post])
  posts: Post[];
}
```