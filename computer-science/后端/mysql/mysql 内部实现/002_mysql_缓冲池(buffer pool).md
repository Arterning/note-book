按页(4K)读取 一次至少读一页数据（一般是4K）
MYSQL的页大小是8页。。特么的为啥不一次读8页？？
InnoDB是以什么算法，来管理这些缓冲页呢？
最容易想到的，就是LRU(Least recently used)。
画外音：memcache，OS都会用LRU来进行页置换管理，但MySQL的玩法并不一样。

预读(Read-Ahead)，提前把页放入了缓冲池，但最终MySQL并没有从页中读取数据，称为预读失效。
要优化预读失效，思路是：
（1）让预读失败的页，停留在缓冲池LRU里的时间尽可能短；
（2）让真正被读取的页，才挪到缓冲池LRU的头部；


具体方法是：
（1）将LRU分为两个部分：
新生代(new sublist)
老生代(old sublist)
（2）新老生代收尾相连，即：新生代的尾(tail)连接着老生代的头(head)；
（3）新页（例如被预读的页）加入缓冲池时，只加入到老生代头部：


（1）整个LRU长度是10；
（2）前70%是新生代；
（3）后30%是老生代；
（4）新老生代首尾相连；

假如有一个页号为50的新页被预读加入缓冲池：
（1）50只会从老生代头部插入，老生代尾部（也是整体尾部）的页会被淘汰掉；
（2）假设50这一页不会被真正读取，即预读失败，它将比新生代的数据更早淘汰出缓冲池；

假如50这一页立刻被读取到，例如SQL访问了页内的行row数据：
（1）它会被立刻加入到新生代的头部；
（2）新生代的页会被挤到老生代，此时并不会有页面被真正淘汰；

MySQL缓冲池加入了一个“老生代停留时间窗口”的机制：
用来解决大量数据导致的缓冲池污染问题呢？
（1）假设T=老生代停留时间窗口；
（2）插入老生代头部的页，即使立刻被访问，并不会立刻放入新生代头部；
（3）只有满足“被访问”并且“在老生代停留时间”大于T，才会被放入新生代头部；


参数：innodb_buffer_pool_size
介绍：配置缓冲池的大小，在内存允许的情况下，DBA往往会建议调大这个参数，越多数据和索引放到内存里，数据库的性能会越好。
参数：innodb_old_blocks_pct
介绍：老生代占整个LRU链长度的比例，默认是37，即整个LRU中新生代与老生代长度比例是63:37。
画外音：如果把这个参数设为100，就退化为普通LRU了。
参数：innodb_old_blocks_time
介绍：老生代停留时间窗口，单位是毫秒，默认是1000，即同时满足“被访问”与“在老生代停留时间超过1秒”两个条件，才会被插入到新生代头部。

总结
（1）缓冲池(buffer pool)是一种常见的降低磁盘访问的机制；
（2）缓冲池通常以页(page)为单位缓存数据；
（3）缓冲池的常见管理算法是LRU，memcache，OS，InnoDB都使用了这种算法；
（4）InnoDB对普通LRU进行了优化：

将缓冲池分为老生代和新生代，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，以解决预读失效的问题
页被访问，且在老生代停留时间超过配置阈值的，才进入新生代，以解决批量数据访问，大量热数据淘汰的问题