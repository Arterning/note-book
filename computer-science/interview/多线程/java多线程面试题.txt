一个线程的生命周期有哪几种状态？它们之间如何流转的？
NEW：毫无疑问表示的是刚创建的线程，还没有开始启动。 
RUNNABLE: 表示线程已经触发 start()方式调用，线程正式启动，线程处于运行中状态。 
BLOCKED：表示线程阻塞，等待获取锁，如碰到 synchronized、lock 等关键字等占用临界区的情况，一旦获取到锁就进行 RUNNABLE 状态继续运行。 
WAITING：表示线程处于无限制等待状态，等待一个特殊的事件来重新唤醒，如通过wait()方法进行等待的线程等待一个 notify()或者 notifyAll()方法，通过 join()方法进行等待的线程等待目标线程运行结束而唤醒，一旦通过相关事件唤醒线程，线程就进入了 RUNNABLE 状态继续运行。 
TIMED_WAITING：表示线程进入了一个有时限的等待，如 sleep(3000)，等待 3 秒后线程重新进行 RUNNABLE 状态继续运行。 
TERMINATED：表示线程执行完毕后，进行终止状态。需要注意的是，一旦线程通过 start 方法启动后就再也不能回到初始 NEW 状态，线程终止后也不能再回到 RUNNABLE 状态


sleep 、wait、yield的区别

sleep：

● 让当前线程休眠指定时间
● 不释放锁资源
● 可通过调用interrupt()方法来唤醒休眠线程

wait：

● 让当前线程进入等待状态，当其他线程调用notify或者notifyAll方法时，当前线程进入就绪状态
● 当前线程会释放已获取的锁资源，并进入等待队列
● 只能在synchronized中使用 因为wait会释放锁

yield：

● 让出线程当前的CPU执行时间，当前线程进入就绪状态,不阻塞当前线程，只是让同优先级或者更高优先级的线程优先执行
● 线程下次调度时依旧有可能执行到


join:
● 实际上join方法就是调用了wait方法来使得线程阻塞，一直到线程结束运行
https://zhuanlan.zhihu.com/p/258581678
//t1.join()前的代码
synchronized (t1) {
 // 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束
 while (t1.isAlive()) {
    wait(0);
 }
}
//t1.join()后的代码



interrupt:
打断正在睡眠的线程
也可以打断正在运行的线程




新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？
用 join 方法。 

怎么控制同一时间只有 3 个线程运行？
用 Semaphore。 






能否从偏向锁直接升级成重量级锁。
锁的升级
             CAS      mutex
无锁、偏向锁、轻量级锁、重量级锁
当对象正处于偏向锁时，调用HashCode将使偏向锁强制升级成重量锁。

轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。

可以简单认为轻量级锁就是使用了自旋锁的概念

首先上结论，一个对象在调用原生hashCode方法后（来自Object的，未被重写过的），该对象将无法进入偏向锁状态，起步就会是轻量级锁。
若hashCode方法的调用是在对象已经处于偏向锁状态时调用，它的偏向状态会被立即撤销，并且锁会升级为重量级锁。


为什么？因为都和对象头有关，计算过的hash值是存放在对象头里面的
在Java语言里面一个对象如果计算过哈希码，就应该一直保持该值不变（强烈推荐但不强制，因为用户可以重载hashCode()方法按自己的意愿返回哈希码），否则很多依赖对象哈希码的API都可能存在出错风险。

而作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code)，这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。

因此，当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObiectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。

偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数-XX:-UseBiasedLocking来禁止偏向锁优化反而可以提升性能"。



什么是自旋锁？
自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时才能进入临界区。 


核心线程池的数目设置
对于 CPU 密集型的计算场景，理论上线程的数量 = CPU 核数就是最合适的，不过通常把线程的数量设置为CPU 核数 +1，会实现最优的利用率。



对于 IO 密集型任务最大线程数一般会大于 CPU 核心数很多倍，因为 IO 读写速度相比于 CPU 的速度而言是比较慢的，如果我们设置过少的线程数，就可能导致 CPU 资源的浪费
《Java并发编程实战》的作者 Brain Goetz 推荐的计算方法如下：
线程数 = CPU 核心数 * (1 + IO 耗时/ CPU 耗时)
大概就是和IO耗时成正比
和CPU耗时成反比
最大线程数：2*N（CPU核数）
也许是从统计上来说IO耗时和CPU耗时在统计学上来说是五五开
