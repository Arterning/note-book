## 为什么要引入keep-alive

通常一个网页可能会有很多组成部分，除了文本内容，还会有诸如：js、css、图片等静态资源，有时还会异步发起AJAX请求。

只有所有的资源都加载完毕后，我们看到网页完整的内容。然而，一个网页中，可能引入了几十个js、css文件，上百张图片，

如果每请求一个资源，就创建一个连接，然后关闭，代价实在太大了。

基于此背景，我们希望连接能够在短时间内得到复用，在加载同一个网页中的内容时，尽量的复用连接，这就是HTTP协议中keep-alive属性的作用。

HTTP 1.0 中默认是关闭的，需要在http头加入"Connection: Keep-Alive"，才能启用Keep-Alive；
HTTP 1.1 中默认启用Keep-Alive，如果加入"Connection: close "，才关闭。

## 什么是keep-alive
keep-alive 是客户端和服务端的一个约定，如果开启 keep-alive，则服务端在返回 response 后不关闭 TCP 连接；

同样的，在接收完响应报文后，客户端也不关闭连接，发送下一个 HTTP 请求时会重用该连接。

在 HTTP/1.0 协议中，如果请求头中包含：

Connection: keep-alive
则代表开启 keep-alive，而服务端的返回报文头中，也会包含相同的内容。

在 HTTP/1.1 协议中，默认开启 keep-alive，除非显式地关闭它：

Connection: close

## http1.0 和 http1.1 的区别


HTTP 1.0和HTTP 1.1是两个不同版本的HTTP协议，它们在功能和性能方面有一些重要的区别。以下是HTTP 1.0和HTTP 1.1之间的主要区别：

1. **持久连接（Persistent Connections）：**
   - HTTP 1.0：默认情况下，每次请求/响应都会建立一个新的连接，这导致了不必要的连接开销。
   - HTTP 1.1：引入了持久连接，即在单个连接上可以发送多个请求和接收多个响应，减少了连接的建立和关闭次数，从而提高了性能。

2. **管线化（Pipeline）：**
   - HTTP 1.0：不支持管线化，即在一个连接上同时发送多个请求。每个请求必须等待前一个请求的响应返回后才能发送。
   - HTTP 1.1：支持管线化，可以在一个连接上同时发送多个请求，减少了请求的等待时间，提高了效率。然而，由于代理和服务器可能不支持管线化，它的实际效果有时可能有限。

3. **缓存控制（Caching）：**
   - HTTP 1.0：缓存控制相对较简单，主要依赖于`Expires`头部来指定资源的过期时间。
   - HTTP 1.1：引入了更强大的缓存控制机制，使用`Cache-Control`头部来定义各种缓存策略，例如`max-age`、`no-cache`、`no-store`等，使得缓存管理更加灵活。

4. **错误处理（Error Handling）：**
   - HTTP 1.0：错误响应通常不包含详细的错误信息，而是简单的状态码和文本描述。
   - HTTP 1.1：引入了更丰富的错误处理机制，可以在响应中包含详细的错误信息，帮助开发者更好地理解问题所在。

5. **虚拟主机（Virtual Hosting）：**
   - HTTP 1.0：虚拟主机需要使用不同的IP地址来区分，因为请求中没有提供主机名的字段。
   - HTTP 1.1：在请求头中引入了`Host`字段，使得虚拟主机可以使用相同的IP地址进行区分，提高了主机的灵活性。

6. **字节范围请求（Byte Range Requests）：**
   - HTTP 1.0：不支持通过字节范围请求来获取文件的部分内容。
   - HTTP 1.1：支持字节范围请求，允许客户端仅请求文件的特定部分，适用于大文件下载、断点续传等。

总的来说，HTTP 1.1引入了许多优化和功能性改进，提高了性能和灵活性，使得网络通信更加高效。它是HTTP 1.0的一个进化版本，被广泛用于现代Web应用中。


