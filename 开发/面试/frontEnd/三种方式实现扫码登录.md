
当我们访问网页端的登录页面时，会向服务器请求获取二维码登录的请求。服务器接收到请求后，会生成一个uuid，并记录下来，然后将该uuid返回网页端。网页端接收到返回结果后，会生成一张二维码图片，其中返回的uuid信息也会融入二维码中。接下来，网页端会不断向服务器发送请求询问该二维码的状态，若使用手机成功扫码，网页端将会收到登录成功和用户信息；若超过一定时间仍无其他操作，网页端将会收到二维码失效的信息，需要重新刷新生成新的二维码。


![[Pasted image 20240313140805.png]]



#### APP认证机制

我们还得认识一下基于APP的移动互联网认证机制。

首先，手机端一般是不会存储登录密码的，我们我们发现，只有装载APP，第一次登录的时候，才需要进行基于账号密码的登录，之后即使这个清理掉这个应用进程，甚至手机重启，都是不需要再次输入账号密码的，它可以自动登录。

这背后有一套基于token的认证机制，和PC有些类似，但又有一些不同。


![[Pasted image 20240313140832.png]]



- APP登录认证的时候除了账号密码，还有设备信息
- 账号密码校验通过，服务端会把账号与设备进行一个绑定，进行持久化的保存，包含了账号ID，设备ID，设备类型等等
- APP每次请求除了携带token key，还需要携带设备信息。

因为移动端的设备具备唯一性，可以为每个客户端生成专属token，这个token也不用过期，所以这就是我们可以一次登录，长久使用的原理。



### 手机确认登录

![[Pasted image 20240313141224.png]]

- 手机端通过带认证信息(token key、设备信息)、二维码信息（二维码ID）请求服务端，完成认证过程，确认PC端的登录。



### PC端如何完成登录

接下来到我们的重头戏了，手机端完成了它的工作，我们服务端的登录怎么进入登录状态呢？

我们前面讲了，PC端通过token来标识登录状态。那么手机端扫码确认之后，我们的服务端就应该给PC生成相应的token。

那么，这个PC端又如何获取它所需的token key，来完成登录呢？

有2种思路
1. 客户端不断轮询
2. 服务器主动推送PC token 给客户端

PC端可以通过获取二维码的状态来进行相应的响应：

- 二维码`未扫描`：无操作
- 二维码`已失效`：提示刷新二维码
- 二维码`已成功`：从服务端获取PC token



# 实现扫码登录

下面实现用三种方式来实现扫码登录，分别为：**轮询**、**长轮询**和**Websocket**。

- **轮询**：网页端按照指定时间间隔不断向服务器发送请求，服务器接收到请求后马上响应信息并关闭连接。优点在于后台程序易于编写；缺点在于会产生大量无用请求，浪费带宽和服务器资源，且更需要更快的处理速度。
- **长轮询**：网页端向服务器发送请求，服务器接收到请求后会进行阻塞，直到有新的信息更新（如扫码成功）或者超时，网页端收到响应的结果后会按需继续向服务器发送新的请求。优点在于不会频繁的请求，耗费资源较小；缺点在于服务器在阻塞请求时会增加资源消耗，且更需要处理并发能力。
- **Websocket**：轮询和长轮询存在无法主动推送数据的缺陷，而Websocket可以做到在网页端和服务器建立连接后，在信息更新后，服务端可以主动推送信息给网页端。优点在于实现了双向通信；缺点在于后台实现逻辑较为复杂。  


    从兼容性角度上考虑：轮询 > 长轮询 > Websocket；  
    从性能角度上考虑：Websocket > 长轮询 > 轮询


![[Pasted image 20240313141415.png]]



![[Pasted image 20240313141442.png]]



![[Pasted image 20240313141449.png]]





## 总结

二维码的本质就是一个uuid 这个uuid有几种状态


- 可以登录
- 过期
- 未扫描


当用户拿起手机扫描的时候，会把这个uuid和手机token发送给服务器，服务器就会把这个uuid的状态设置为可以登录，生成pc token。


然后客户端就可以通过这个uuid拿到pc token。

