
## 构造函数

讲原型则离不开构造函数，让我们先来认识下构造函数。

#### 2.1 构造函数分为 实例成员 和 静态成员

让我们先来看看他们分别是什么样子的。

**实例成员：** 实例成员就是在构造函数内部，通过this添加的成员。实例成员只能通过实例化的对象来访问。

**静态成员：** 在构造函数本身上添加的成员，只能通过构造函数来访问


```js
    function Star(name,age) {
        //实例成员
        this.name = name;
        this.age = age;
    }
    //静态成员
    Star.sex = '女';

    let stars = new Star('小红',18);
    console.log(stars);      // Star {name: "小红", age: 18}
    console.log(stars.sex);  // undefined     实例无法访问sex属性

    console.log(Star.name); //Star     通过构造函数无法直接访问实例成员
    console.log(Star.sex);  //女       通过构造函数可直接访问静态成员
```


#### 2.2 通过构造函数创建对象

该过程也称作实例化

##### 2.2.1 如何通过构造函数创建一个对象？

```javascript
 function Father(name) {
     this.name = name;
 }
 let son = new Father('Lisa');
 console.log(son); //Father {name: "Lisa"}
```


此时，son就是一个新对象。


##### 2.2.2 new一个新对象的过程，发生了什么？

(1) 创建一个空对象 son `{}`

(2) 为 son 准备原型链连接 `son.__proto__ = Father.prototype`

(3) 重新绑定this，使构造函数的this指向新对象 `Father.call(this)`

(4) 为新对象属性赋值 `son.name`

(5) 返回this `return this`，此时的新对象就拥有了构造函数的方法和属性了

##### 2.2.3 每个实例的方法是共享的吗？

这要看我们如何定义该方法了，分为两种情况。


###### 方法1：在构造函数上直接定义方法（不共享）

```js
    function Star() {
        this.sing = function () {
            console.log('我爱唱歌');
        }
    }
    let stu1 = new Star();
    let stu2 = new Star();
    stu1.sing();//我爱唱歌
    stu2.sing();//我爱唱歌
    console.log(stu1.sing === stu2.sing);//false
```

很明显，stu1 和 stu2 指向的不是一个地方。

所以 在构造函数上通过this来添加方法的方式来生成实例，每次生成实例，都是新开辟一个内存空间存方法。这样会导致内存的极大浪费，从而影响性能。



###### 方法2：通过原型添加方法（共享）

构造函数通过原型分配的函数，是所有对象共享的。

```js
    function Star(name) {
        this.name = name;
    }
    Star.prototype.sing = function () {
        console.log('我爱唱歌', this.name);
    };
    let stu1 = new Star('小红');
    let stu2 = new Star('小蓝');
    stu1.sing();//我爱唱歌 小红
    stu2.sing();//我爱唱歌 小蓝
    console.log(stu1.sing === stu2.sing);//true
```


##### 2.2.4 实例的属性为基本类型是，它们是共享的吗？

属性存储的是如果存储的是基本类型，不存在共享问题，是否相同要看值内容。

```js
    let stu1 = new Star('小红');
    let stu2 = new Star('小红');
    console.log(stu1.name === stu2.name);//true

    let stu1 = new Star('小红');
    let stu2 = new Star('小蓝');
    console.log(stu1.name === stu2.name);//false
```





结论：原型有什么用，我们可以给构造函数的prototype上指定方法，实现所有对象共享一个方法，其实这个本来就是应该的。。。但是在js中，我们必须通过原型这么做。。。

























