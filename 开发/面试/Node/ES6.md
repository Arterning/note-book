
var const let
用`var`声明的变量既是全局变量，也是顶层变量
使用`var`，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明

在函数中使用使用`var`声明变量时候，该变量是局部的
而如果在函数内不使用`var`，该变量是全局的

`var`声明的变量存在变量提升，即变量可以在声明之前调用，值为`undefined`
`let`和`const`不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错

`var`不存在块级作用域
`let`和`const`存在块级作用域

`var`允许重复声明变量
`let`和`const`在同一作用域不允许重复声明变量



`let`是`ES6`新增的命令，用来声明变量
用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效



`const`声明一个只读的常量，一旦声明，常量的值就不能改变
`const`实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动
对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量
对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，`const`只能保证这个指针是固定的，并不能确保改变量的结构不变



### 使用

能用`const`的情况尽量使用`const`，其他情况下大多数使用`let`，避免使用`var`






ES Module

```js

export {a, b, c}


import {a, b, c as CC} from 'xx'
import * from 'xx'
```




如果不需要知道变量名或函数就完成加载，就要用到`export default`命令，为模块指定默认输出

```js


export default HomePage


// `import`命令可以为该函数指定任意名字
import HomePage from 'xx'
```



### 动态加载

允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势

这个新功能允许您将`import()`作为函数调用，将其作为参数传递给模块的路径。 它返回一个 `promise`，它用一个模块对象来实现，让你可以访问该对象的导出

```
import('/modules/myModule.mjs')
  .then((module) => {
    // Do something with the module.
  });
```


