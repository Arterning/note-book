
### generator

`yield`表达式可以暂停函数执行，`next`方法用于恢复函数执行，这使得`Generator`函数非常适合将异步任务同步化

```
const gen = function* () {
  const f1 = yield readFile('/etc/fstab');
  const f2 = yield readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
```


### async/await

将上面`Generator`函数改成`async/await`形式，更为简洁，语义化更强了

```
const asyncReadFile = async function () {
  const f1 = await readFile('/etc/fstab');
  const f2 = await readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
```


### 区别：

通过上述代码进行分析，将`promise`、`Generator`、`async/await`进行比较：

- `promise`和`async/await`是专门用于处理异步操作的
    
- `Generator`并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署`Interator`接口...）
    
- `promise`编写代码相比`Generator`、`async`更为复杂化，且可读性也稍差
    
- `Generator`、`async`需要与`promise`对象搭配处理异步情况
    
- `async`实质是`Generator`的语法糖，相当于会自动执行`Generator`函数
    
- `async`使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案