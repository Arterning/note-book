---
title: 第十六篇：TCP 网络！三次握手、四次挥手、TIME-WAIT、HTTP 2.0
---

# TCP 网络那点破事！三次握手、四次挥手、TIME-WAIT、HTTP 2.0

> 作者：Tom哥
> <br/>公众号：微观技术
> <br/> 博客：[https://offercome.cn](https://offercome.cn)
> <br/> 人生理念：知道的越多，不知道的越多，努力去学


## **OSI 七层模型，每层的作用？**<br /><br />
答案：分为7层，从下到上依次是：

- 应用层：计算机用户与网络之间的接口，常见的协议有：HTTP、FTP、 SMTP、TELNET
- 表示层：数据的表示、安全、压缩。将应用处理的信息转换为适合网络传输的格式。
- 会话层：建立和管理本地主机与远程主机之间的会话。
- 传输层：定义传输数据的协议端口号，以及流控和差错校验，保证报文能正确传输。协议有TCP、UDP
- 网络层：路由选择算法，进行逻辑地址寻址，实现不同网络之间的最佳路径选择。协议有IP、ICMP
- 数据链路层：每⼀台设备的⽹卡都会有⼀个 MAC 地址，它就是⽤来唯⼀标识设备的。路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。路由器就是通过数据链路层来知道这个 ip 地址是属于哪个设备的，它主要**为⽹络层提供链路级别传输的服务**。
- 物理层：建立、维护、断开物理连接。传输比特流（将1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。

![](https://cdn.nlark.com/yuque/0/2022/png/21503536/1666969661531-60872b47-444c-454b-884a-d0df5af4a4e1.png#clientId=ue51e36ec-1f8f-4&from=paste&height=424&id=u86a8fb99&originHeight=682&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub5e708ed-b17d-47a0-9509-05bb2a92fec&title=&width=671)

## **TCP 报文首部有哪些字段?**<br /><br />
答案：<br />![](https://cdn.nlark.com/yuque/0/2022/png/21503536/1666969661509-d5ef9a2a-ce78-48ed-8c2f-4c9ac997e77b.png#clientId=ue51e36ec-1f8f-4&from=paste&id=u9c6c9265&originHeight=375&originWidth=571&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u69649d64-20a0-4fc8-aa8b-605a2a3b90d&title=)

- 源端口、目的端口：各占2个字节，表示数据从哪个进程来，去往哪个进程
- 序号（Sequence Number）：占4个字节，TCP连接中传送的数据每一个字节都会有一个序号
- 确认号（Acknowledgement Number）：占4个字节，另一方发送的tcp报文段的响应
- 数据偏移：头部长度，占4个字节，表示TCP报文段的数据距离TCP报文段的起始处有多远。
- 6位标志位：
   - URG：紧急指针是否有效
   - ACK：表示确认号是否有效
   - PSH：提示接收端应用程序立刻将数据从tcp缓冲区读走
   - RST：表示要求对方重新建立连接
   - SYN：这是一个连接请求或连接接受的报文
   - FIN：告知对方本端要关闭连接
- 窗口大小：占4个字节，用于TCP流量控制。告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。
- 校验和：占2个字节，由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。检验的范围包括头部、数据两部分，是TCP可靠传输的一个重要保障。
- 紧急指针：占2个字节，一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号，用于发送端向接收端发送紧急数据。

## TCP 和 UDP 的区别？

答案：<br />![](https://cdn.nlark.com/yuque/0/2022/png/21503536/1666969661528-34af196c-ff2c-41ea-a4d3-e47f79634cb8.png#clientId=ue51e36ec-1f8f-4&from=paste&height=425&id=u7f319dc2&originHeight=898&originWidth=1364&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7e06cf55-2d5b-452d-9c08-e4cbfb387c8&title=&width=645)

## **TCP 三次握手过程？**<br /><br />
答案：目的是同步连接双方的序列号和确认号，并交换TCP窗口。

- 第一次握手，客户端发送(seq=x)，客户端进入SYN_SEND状态
- 第二次握手，服务端响应(Seq=y, Ack=x+1)，服务器端就进入SYN_RCV状态。
- 第三次握手，客户端收到服务端的确认后，发送(Ack=y+1)，客户端进入ESTABLISHED状态。当服务器端接收到这个包时，也进入ESTABLISHED状态。

![](https://cdn.nlark.com/yuque/0/2022/png/21503536/1666969661529-4973e7b0-64a4-427a-9b87-34dba4dd75d7.png#clientId=ue51e36ec-1f8f-4&from=paste&height=418&id=u52008c2a&originHeight=649&originWidth=792&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0a62ac54-4ad0-4157-b556-9b34a79c46a&title=&width=510)

## **TCP 半连接队列和全连接队列？**<br /><br />
答案：<br />![](https://cdn.nlark.com/yuque/0/2022/png/21503536/1666969661417-72a9dfd3-9690-49ad-8007-de8a4d68548c.png#clientId=ue51e36ec-1f8f-4&from=paste&height=601&id=uccaea221&originHeight=918&originWidth=908&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf263b727-9422-4554-a13b-b02a8e771d8&title=&width=594)<br />服务端收到客户端发出的 SYN 请求后，会把这个连接信息存储到**半链接队列 (SYN 队列)**。<br />服务端收到第三次握⼿的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到**全连接队列 **(accept 队列)，等待进程调⽤ accept 函数时把连接取出来。<br />这两个队列都是有大小限制的，当超过容量后就会将链接丢弃，或者返回 RST 包。

## **为什么是三次握手，而不是两次或四次？**

答案：<br />如果只有两次握手，那么服务端向客户端发送 SYN/ACK 报文后，就会认为连接建立。但是如果客户端没有收到报文，那么客户端是没有建立连接的，这就导致服务端会浪费资源。<br />使用两次握手无法建立 TCP 连接，而使用三次握手是建立连接所需要的最小次数

## 三次握手阶段，最后一次ACK包丢失，会发生什么？<br /><br />
答案： <br />**1、服务端：**

- 第三次的ACK在网络中丢失，那么服务端该TCP连接的状态为SYN_RECV，并且会根据 TCP的超时重 传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。
- 如果重发指定次数之后，仍然未收到 客户端的ACK应答，那么一段时间后，服务端自动关闭这个连 接。

**2、客户端：** 客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包（Reset，标示复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。

## **TCP 四次挥手的过程？**<br /><br />
答案：

- 第一次挥手：客户端向服务端发送连接释放报文
- 第二次挥手：服务端收到连接释放报文后，立即发出确认报文。这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。
- 第三次挥手：服务端向客户端发送连接释放报文
- 第四次挥手：客户端收到服务端的连接释放报文后，立即发出确认报文。此时，客户端就进入了 TIME-WAIT 状态。注意此时客户端到 服务端的 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入CLOSED 状态。

![](https://cdn.nlark.com/yuque/0/2022/png/21503536/1666969662127-e977196d-34a3-4629-b4ef-a19a9dee4f1e.png#clientId=ue51e36ec-1f8f-4&from=paste&height=406&id=uf8a162e9&originHeight=661&originWidth=911&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud56f9e16-2972-44c3-b753-07a34208697&title=&width=560)

## **为什么是四次挥手？**<br /><br />
答案：<br />TCP 是全双工。一方关闭连接后，另一方还可以继续发送数据。所以四次挥手，将断开连接分成两个独立的过程。

## **为什么要等 2MSL 才进入 CLOSED 状态？**

答案：<br />MSL 是报文段在网络上最大存活时间。<br />首先 2MSL 的时间是从客户端(A)接收到 **FIN 后发送 ACK 开始计时**的。如果**在 TIME-WAIT 时间内**，因为客户端(A)的 ACK **没有传输**到服务端(B)，客户端(A)又接收到了服务端(B)重发的 FIN 报文，那么 2MSL **时间会被重置**。等待 2MSL 原因如下<br />**1、得原来连接的数据包消失**

- 1）如果B没有收到自己的ACK，会超时重传FIN那么A再次接到重传的FIN，会再次发送ACK
- 2）如果B收到自己的ACK，也不会再发任何消息，
- 在最后一次挥手后 A 并不知道 B 是否接到自己的 信息

包括 ACK 是以上哪两种情况，A 都需要等待，要取这两种情况等待时间的最大值，以应对最坏的情况发生，这个最坏情况是：去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。这刚好是2MSL，这个时间，足以**使得原来连接的数据包在网络中消失**。<br />**2、保证 ACK 能被服务端接收到从而正确关闭链接**

- 因为这个 ACK 是有可能丢失的，会导致服务器收不到对 FIN-ACK 确认报文。假设客户端不等待 2MSL ，而是在发送完 ACK 之后直接释放关闭，一但这个 ACK 丢失的话，服务器就**无法正常的进入关闭连接状态**。

## 如果已经建立了连接，但是客户端出现故障了怎么办？<br /><br />
答案： <br />通过定时器 + 超时重试机制，尝试获取确认，直到最后会自动断开连接。<br />具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 分钟发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。

## TIME_WAIT 是服务器端的状态?还是客户端的状态?<br /><br />
答案：<br />TIME_WAIT 是主动断开连接的一方会进入的状态，一般情况下，都是客户端所处的状态，服务器端一般 设置不主动关闭连接。<br />TIME_WAIT 需要等待 2MSL，在大量短连接的情况下，TIME_WAIT 会太多，这也会消耗很多系统资源。对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题。

## TIME-WAIT 状态过多会产生什么后果？怎样处理？<br /><br />
答案：<br />从服务器来讲，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，严 重消耗着服务器的资源，此时部分客户端就会显示连接不上。<br />从客户端来讲，客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。<br />**解决办法：**

- 服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，此套接字选项告诉内核，即使此端口正忙（处于TIME_WAIT状态），也请继续并重用它。
- 调整系统内核参数，修改/etc/sysctl.conf文件，即修改 net.ipv4.tcp_tw_reuse 和 tcp_timestamps
```
net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连
接，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为
0，表示关闭
```

- 强制关闭，发送 RST 包越过TIME_WAIT状态，直接进入CLOSED状态

## **一台 8G 内存服务器，可以同时维护多少个连接？**

答案：<br />发送、接收缓存各4k，还要考虑socket描述符，一个tcp连接需要占用的最小内存是8k，那么最大连接数为：8*1024*1024 K / 8 K = 1048576 个，即约100万个tcp长连接。

## **什么是拆包？**<br /><br />
答案：<br />发生 TCP **拆包**的**原因**:

- 1.**待发送数据大于最大报文长度**，TCP 在传输前将进行拆包。
- 2.**发送的数据大于 TCP 发送缓冲区剩余空间大小**，将会发生拆包。

传输层封包不能太大，基于这个限制，往往以缓冲区大小为单位，将数据拆分成多个 TCP 段（TCP Segment）传输。在接收数据的时候，一个个 TCP 段又被重组成原来的数据。简单来讲分为几个过程：拆分——传输——重组。

**解决方案**:<br />![](https://cdn.nlark.com/yuque/0/2022/png/21503536/1666969662190-631edbba-7761-4e0a-afc5-668687c795f4.png#clientId=ue51e36ec-1f8f-4&from=paste&height=111&id=u9f852cda&originHeight=206&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubab0c016-8236-4a52-8fbe-e46f3545254&title=&width=584)

- 1.**发送端给每个数据包添加包首部**，首部中包含数据包的长度，这样接收端在接收到数据后，通过该字段就可以知道每个数据包的实际长度了。
- 2.发送端将每个数据包**设置固定长度**，这样接收端每次从读取固定长度的数据把每个数据包拆分开。
- 3.可以在数据包之间**设置边界**，如添加特殊符号，接收端可以通过这个特殊符号来拆分包。

## **什么是粘包？**

答案：<br />解决数据太小问题，防止多次发送占用资源。TCP 协议将它们合并成一个 TCP 段发送，在目的地再还原成多个数据。

## **缓冲区是做什么用？**

答案：<br />缓冲区是在内存中开辟的一块区域，目的是缓冲。当应用频繁地通过网卡收、发数据，网卡只能一个一个处理。当网卡忙不过来的时候，数据就需要排队，也就是将数据放入缓冲区。<br />注意：TCP Segment 的大小不能超过缓冲区大小。

## **TCP 协议是如何保证数据的顺序？**<br /><br />
答案：<br />![](https://cdn.nlark.com/yuque/0/2022/png/21503536/1666969662173-a1af75b7-10fb-42ab-8415-fbb00c8ab37c.png#clientId=ue51e36ec-1f8f-4&from=paste&id=u292f98f2&originHeight=219&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1ef74339-73db-4614-bd88-6be668b9b9e&title=)<br />大数据拆包成多个片段，发送可以保证有序，但是由于网络环境复杂，并不能保证它们到达时也是有序的，为了解决这个问题，对每个片段用Sequence Number编号，接收数据的时候，通过 Seq 进行排序。<br />注意：seq是累计的发送字节数

## **TCP 协议如何解决丢包？**<br /><br />
答案：<br />丢包需要重发，关键是如何判断有没有丢包！<br />每一个数据包，接收方都会给发送方发响应。每个 TCP 段发送时，接收方已经接收了多少数据，用 Acknowledgement Number（简写ACK） 表示。<br />注意：ack是累计的接收字节数，表示这个包之前的包都已经收到了。

## **什么是 MSS ?**<br /><br />
答案：<br />MSS 全称 Maximun Segment Size。是TCP Header 中的可选项（Options），控制了 TCP 段的大小，不能由单方决定，需要双方协商。

## **TCP 滑动窗⼝是什么？**<br /><br />
答案：<br />![](https://cdn.nlark.com/yuque/0/2022/png/21503536/1666969662207-b4af2bfe-f25b-4a41-98b0-8d7fc25328c1.png#clientId=ue51e36ec-1f8f-4&from=paste&height=421&id=u31776379&originHeight=892&originWidth=864&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0e5427cf-0ca7-48c0-a4d4-dcf45d2b544&title=&width=408)<br />TCP 是**每发送⼀个数据，都要进⾏⼀次确认应答**。只有上一个收到了回应才发送下一个，这样**效率会非常低**，因此**引进了滑动窗口**的概念.<br />其实就是在发送方**设立一个缓存区间**，将已发送但未收到确认的消息**缓存**起来，**假如一个窗口可以发送 5 个 TCP 段**，那么发送方就可以连续发送 5 个 TCP 段，然后就会将这 5 个 TCP 段的数据缓存起来，这 5 个 TCP 段是有序的，只要后面的消息收到了 ACK ，那么不管前面的是否有收到 ACK，都代表成功，**窗⼝⼤⼩是由接收方决定的**。<br />窗⼝⼤⼩就是指**不需要等待应答，还可以发送数据的大小**。

## **TCP 如何控制流量传输速度？**<br /><br />
答案：<br />简单讲通过滑动窗口。发送、接收窗口的大小可以用来控制 TCP 协议的流速。窗口越大，同时可以发送、接收的数据就越多，吞吐量也就越大。但是窗口越大，如果数据发生错误，损失也就越大，因为需要重传越多的数据。<br />TCP每个请求都要有响应，如果一个请求没有收到响应，发送方就会认为这次发送出现了故障，会触发重发。为了提升吞吐量，一个TCP段在没有收到响应时，可以继续发送下一个段。<br />![](https://cdn.nlark.com/yuque/0/2022/png/21503536/1666969662364-95bb98e6-2d1a-48f2-9c6c-69b74d5542cb.png#clientId=ue51e36ec-1f8f-4&from=paste&height=339&id=u5864de62&originHeight=589&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2d67a314-ffac-4cc5-91a7-8d556940022&title=&width=622)

- 窗口区域包含两类数据：已发送未确认、未发送（即将发送）
- 窗口中序号最小的分组如果收到 ACK，窗口就会向右滑动
- 滑动窗口的size规格可能会变化，需要从ACK数据包实时取最新值
- 如果最小序号的分组长时间没有收到 ACK，就会触发整个窗口的数据重新发送

## **TCP **保证传输过程的可靠性？<br /><br />
答案：<br />1、校验和：发送⽅在发送数据之前计算校验和，接收⽅收到数据后同样计算，如果不⼀致，那么传输有<br />误。<br />2、确认应答，序列号：TCP进⾏传输时数据都进⾏了编号，每次接收⽅返回ACK都有确认序列号。<br />3、滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法 正常处理的异常。<br />4、超时重传：如果发送⽅发送数据⼀段时间后没有收到ACK，会认为包丢了，重发数据。<br />5、流量控制：TCP协议报头包含16位的窗⼝⼤⼩，接收⽅会在返回ACK时同时把⾃⼰的即时窗⼝填⼊，发送⽅就根据报⽂中窗⼝的⼤⼩控制发送速度。<br />6、拥塞控制：刚开始发送数据的时候，拥塞窗⼝是1，以后每次收到ACK，则拥塞窗⼝+1，然后将拥塞窗⼝和收到的窗⼝取较⼩值作为实际发送的窗⼝，如果发⽣超时重传，拥塞窗⼝重置为1。这样做的⽬的就是为了保证传输过程的⾼效性和可靠性。<br />7、连接管理：三次握⼿和四次挥⼿的过程。

## **TCP 抓包用什么工具？**

答案：<br />Wireshark，应用最广泛的网络协议分析器。功能非常丰富

- 支持数百个协议
- 实时捕获、离线分析
- 支持 Windows、Linux、macOS、Solaris、FreeBSD、NetBSD等平台；
- 界面化操作
- 支持 Gzip
- 支持 IPSec

## **介绍一下 HTTP 协议？**<br /><br />
答案：

![](https://cdn.nlark.com/yuque/0/2022/png/21503536/1666969662644-c9557400-8b01-48b3-8822-2a2b2d4927fa.png#clientId=ue51e36ec-1f8f-4&from=paste&height=91&id=u8303f327&originHeight=194&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucf3756d8-422b-4bbe-b908-8361527a677&title=&width=504)

HTTP 协议是**基于 TCP 协议**实现的，它是一个**超文本传输协议**，其实就是一个简单的请求-响应协议，它**指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应**。

它主要是**负责点对点之间通信**的。

- **超文本：**就是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。比如说html，内部定义了很多图片视频的链接，放在浏览器上就呈现出了画面。
- **协议：**就是约定俗成的东西，比如说 Tom哥 要给读者送一本书，读者那里只接受顺丰快递，那么 Tom哥 觉得可以，发快递的时候选择的顺丰，那么我们彼此之间共同约定好的就叫做协议。
- **传输：**这个就很好理解了，比如刚才举的例子，将书发给读者，要通过汽车或者飞机的方式，传递的这个过程就是运输。

## **GET 和 POST 区别？**<br /><br />
答案：<br />GET 和 POST 本质上就是 TCP 链接，并无差别。<br />但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

| **区别** | **GET** | **POST** |
| --- | --- | --- |
| 数据传输方式 | 从服务器获取数据 | 向服务器提交数据 |
| 对数据长度的限制 | 当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符） | 无限制 |
| 对数据类型的限制 | 只允许 ASCII 字符 | 无限制 |
| 安全性 | 较差，所发送的数据是 URL 的一部分，会显示在网页上 | 较好，参数不会被保存在浏览器历史或 WEB 服务器日志中 |
| 可见性 | 显示在 URL 上 | 不显示 |
| 收藏为书签 | 可以 | 不可以 |
| 历史记录 | 可以被保留在历史记录当中 | 不可以被保留 |
| 缓存 | 能被缓存 | 不可以被缓存 |


## HTTP 状态码有哪些？<br /><br />
答案：

| **1xx** | **信息，服务器收到请求，需要请求者继续执行操作** |
| --- | --- |
| 2xx | 成功，操作被成功接收并处理 |
| 3xx | 重定向，需要进一步的操作以完成请求 |
| 4xx | 客户端错误，请求包含语法错误或无法完成请求 |
| 5xx | 服务器错误，服务器在处理请求的过程中发生了错误 |


**常见状态码：**

- 200：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
- 301 ： (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。
- 302：(临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
- 400 ：客户端请求有语法错误，不能被服务器所理解。
- 403 ：服务器收到请求，但是拒绝提供服务。
- 404 ：(未找到) 服务器找不到请求的网页。
- 500： (服务器内部错误) 服务器遇到错误，无法完成请求。

## **HTTP 1.0 、1.1 和 HTTP 2.0 有什么区别？**<br /><br />
答案：<br />**1、HTTP 1.0**

- 默认是短连接，每次与服务器交互，都需要新开一个连接。

**2、HTTP 1.1**

- 默认持久化连接，建立一次连接，多次请求均由这个连接完成。
- **引入**更多的缓存控制策略**，**如 ：Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
- 新增了24个错误状态响应码，如 410（Gone）表示服务器上的某个资源被永久性的删除等。
- 新增了 range 字段，用来指定数据字节位置，开启了断点续传的时代

**3、HTTP 2.0**

- 二进制分帧：在应用层和传输层之间加了一个二进制分帧层，将所有传输的信息分割为更小的消息和帧（frame），并对它们采用二进制格式的编码。减少服务端的压力，内存占用更少，连接吞吐量更大
- 多路复用：允许同时通过单一的HTTP/2.0连接发起多次的请求-响应消息。
- 头部压缩：采用了Hpack头部压缩算法对Header进行压缩，减少重复发送。
- 服务器推送：服务器主动将一些资源推送给浏览器并缓存起来。

## **HTTP2 和 HTTP3 区别是什么？**

答案：<br />![](https://cdn.nlark.com/yuque/0/2022/png/21503536/1666969662722-0651f557-e222-4d9e-8408-cbe0049ebbcd.png#clientId=ue51e36ec-1f8f-4&from=paste&height=108&id=ud82d38e0&originHeight=234&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uecc6065e-2e71-4ca6-8463-3ad31f2a64b&title=&width=498)

- 1.**协议不同**
   - HTTP2 是基于 **TCP** 协议实现的
   - HTTP3 是基于 **UDP** 协议实现的
- 2.**QUIC**
   - **HTTP3 新增了 QUIC 协议**来实现可靠性的传输
- 3.**握手次数**
   - HTTP2 是基于 HTTPS 实现的，建立连接需要先进行 TCP 3次握手，然后再进行 TLS 3次握手，**总共6次握手**
   - HTTP3 只需要 QUIC 的**3次握手**

## **HTTP 与 HTTPS 的区别？**

答案：<br />HTTPS = HTTP + SSL/TLS<br />HTTPS 在HTTP的基础上加入了SSL/TLS协议，SSL/TLS 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

- SSL安全协议
   - HTTP 是超⽂本传输协议，信息是**明⽂传输**，存在安全⻛险的问题。
   - HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够**加密传输**。
- 建立连接
   - HTTP 连接建⽴相对简单， TCP **三次握⼿**之后便可进⾏ HTTP 的报⽂传输。
   - HTTPS 在 TCP **三次握⼿**之后，还需进⾏ **SSL/TLS** 的握⼿过程，才可进⼊加密报⽂传输。
- 端口号
   - HTTP 的端⼝号是 **80**。
   - HTTPS 的端⼝号是 **443**。
- CA证书
   - **HTTPS 协议需要向 CA（证书权威。机构）申请数字证书**来保证服务器的身份是可信的。

## **HTTP 协议为什么要设计成无状态？**<br /><br />
答案：<br />HTTP是一种无状态协议，每个请求都是独立执行，请求/响应。这样设计的重要原因是，降低架构设计复杂度，毕竟服务器一旦带上了状态，扩容、缩容、路由都会受到制约。无状态协议不要求服务器在多个请求期间保留每个用户的信息。<br />但，你可能会问，如果有登录要求的业务怎么办？HTTP协议提供扩展机制，Header中增加了Cookie，存储在客户端，每次请求时自动携带，采用空间换时间机制，满足上下请求关联。虽然浪费了些网络带宽，但是减少了复杂度。当然为了减轻网络负担，浏览器会限制Cookie的大小，不同浏览器的限制标准略有差异，如：Chrome 10，限制最多 180个，每个Cookie大小不能超过 4096 bytes

## **HTTPS 访问流程是什么？**<br /><br />
答案：

- 客户端发起一个http请求，告诉服务器自己支持哪些hash算法。
- 服务端选择浏览器支持的加密和hash算法，把自己的信息以数字证书的形式返回给客户端（公钥在证书里面，私钥由服务器持有）。
- 客户端收到服务器的响应后会先验证证书的合法性（证书中包含的网址与正在访问的网址是否一致，证书是否过期）
- 如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。
- 客户端将证书公钥加密后的密钥发送给服务端
- 服务端用私钥解密，解密之后就得到客户端的密钥
- 然后，客户端与服务端通过对称密钥完成明文加密、安全通信、对称解密

## **对称加密与非对称加密有什么区别？**<br /><br />
答案：

- 对称加密。加密和解密使用同一个密钥。速度快。常用的如：AES、DES
- 非对称加密。公钥与私钥配对出现，公钥对数据加密，私钥对数据解密。常用的如：RSA、DSS

## **PING 的作用？**<br /><br />
答案：<br />PING 主要的作用就是**测试在两台主机之间能否建立连接**，如果 PING 不通就无法建立连接。<br />它其实就是向目的主机发送多个 ICMP 回送请求报文

- 如果没有响应则无法建立连接
- 如果有响应就可以根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包**往返时间及丢包率**

## **浏览器地址栏输入网站按回车后发生了什么？**<br /><br />
答案：<br />![](https://cdn.nlark.com/yuque/0/2022/png/21503536/1666969662702-8cdea552-b591-482c-9141-fb77b46a6611.png#clientId=ue51e36ec-1f8f-4&from=paste&height=212&id=u8df548c6&originHeight=430&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u22eba686-7b94-41bb-b6da-5674479611d&title=&width=533)<br />1、解析网址，生成 HTTP 请求信息<br />2、根据 DNS 服务器查询真实请求的 IP 地址，如果本地服务器有缓存则直接返回<br />3、得到了 IP 以后，向服务器发送 TCP 连接，TCP 连接经过三次握手。<br />4、接收 TCP 报文后，对连接进行处理，对 HTTP 协议解析<br />5、服务器返回响应<br />6、浏览器接收响应，显示页面，渲染页面

## 负载均衡哪些实现⽅式？<br /><br />
答案：<br />**1、DNS**<br />这是最简单的负载均衡的⽅式，⼀般⽤于实现地理级别的负载均衡，不同地域的⽤户通过DNS的<br />解析可以返回不同的IP地址，这种⽅式的负载均衡简单，但是扩展性太差，控制权在域名服务商。<br />**2、Http 重定向**<br />通过修改Http响应头的Location达到负载均衡的⽬的，Http的302重定向。这种⽅式对性能有影响，⽽且增加请求耗时。<br />**3、反向代理**<br />作⽤于应⽤层的模式，也被称作为七层负载均衡，⽐如常⻅的Nginx，性能⼀般可以达到万级。这种⽅式部署简单，成本低，⽽且容易扩展。<br />**4、IP**<br />作⽤于⽹络层的和传输层的模式，也被称作四层负载均衡，通过对数据包的IP地址和端⼝进⾏修改<br />来达到负载均衡的效果。常⻅的有LVS（Linux Virtual Server）
:::info
按照类型来划分的话，还可以分成DNS负载均衡、硬件负载均衡、软件负载均衡。其中硬件负载均衡价格昂贵，性能最好，能达到百万级，软件负载均衡包括Nginx、LVS这种。
:::

## 什么是 Cookie？<br /><br />
答案：<br />HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。 <br />**Cookie 主要用于以下三个方面：**

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等） 

## 什么是 Session？<br /><br />
答案：<br />Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。

## 分布式 Session 解决方案？

答案：

- 客户端存储：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过 http协议和服务器进行 cookie 交互，通常用来存储一些不敏感信息
- Nginx ip_hash 策略：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。
- Session 复制：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。
- 共享 Session：服务端无状态话，将用户的 Session 等信息使用缓存中间件（如：Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。

## 什么是 XSS 攻击？<br /><br />
答案： <br />XSS 也称 cross-site scripting，跨站脚本攻击。这种攻击是由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的。比如一个存在XSS漏洞的论坛，用户发帖时就可以引入带有＜script＞标签的代码，导致恶意代码的执行。<br />**解决方案：**

- 前端：过滤。
- 后端：转义，比如go自带的处理器就具有转义功能

## 如何避免 SQL 注入？

答案：<br />SQL 注入就是在用户输入的字符串中加入 SQL 语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的 SQL 语句就会被数据库服务器误认为是正常的 SQL 语句而运行，攻击者就可以执行计划外的命令或访问未被授权的数据。<br />**解决方案：**

- 限制数据库权限，给用户提供仅仅能够满足其工作的最低权限。
- 对进入数据库的特殊字符（’”\尖括号&*;等）转义处理。
- 提供参数化查询接口，不要直接使用原生SQL。

## 负载均衡算法有哪些？<br /><br />
答案：<br />多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。

- 轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势。
- 随机法：随机获取一台，和轮询类似。
- 哈希法：通过ip地址哈希化来确定要选择的服务器编号。好处每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie。
- 加权轮询：根据服务器性能不同加权。
