

多级反馈队列( Multi-Level Feedback Queue )尝试去同时解决响应时间和周转时间两个问题，具体做法：

- 设置了多个任务队列，每个队列对应的优先级不同，队列内部的优先级相同
    
- 优先分配CPU给高优先级的任务，同优先级队列中的任务采用RR轮询机制
    
- 通过对任务运行状态的追踪来调整优先级，也就是所谓的Feedback反馈机制
    
- 任务在运行期间有较多IO请求和等待，预测为交互进程，优先级保持或提升
    
- 任务在运行期间一直进行CPU计算，预测为非交互进程，优先级保持或下降
    
- 最初将所以任务都设置为高优先级队列，随着后续的运行状态再进行调整
    
- 运行期间有IO操作则保持优先级
    
- 运行期间无IO操作则把任务放到低一级的队列中
    
- 不同队列分配不同的时间片
    
- 高优先级队列往往是IO型任务，配置较小的时间片来保障响应时间
    
- 低优先级队列往往是CPU型任务，配置较长时间片来保障任务一直运行


![[Pasted image 20240402152016.png]]



上述是MLFQ算法的基本规则，在实际应用中仍然会有一些问题：

- 饥饿问题
    
- CPU密集型的任务随着时间推移优先级会越来越低，在IO型进程多的场景下很容易出现饥饿问题，一直无法得到调度
    
- 任务是CPU密集型还是IO密集型可能是动态变化的，低优先级队列中的IO型任务的响应时间被拉升，调度频率下降
    
- 作弊问题
    
- 基于MLFQ对IO型任务的偏爱，用户可能为CPU密集型任务编写无用的IO空操作，从而人为提升任务优先级，相当于作弊
    

针对上述问题MLFQ还需增加几个补丁：

- 周期性提升所有任务的优先级到最高，避免饥饿问题
    
- 调度程序记录任务在某个层级队列中消耗的时间片，如果达到某个比例，无论期间是否有IO操作都降低任务的优先级，通过计时来确定真正的IO型任务
    

MLFQ的算法思想在1962年被提出，其作者也获得了图灵奖，可谓是影响深远。

在朴素MLFQ算法基础上出现一些变种，通过工程实现和经验配置最终被使用到操作系统中，成为真正的工业级进程调度器。