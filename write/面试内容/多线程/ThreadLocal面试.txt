ThreadLocal原理

实际上ThreadLocalMap是定义在Thread对象里面的
Key是ThreadLocal value是Thread要使用的对象 比如SimpleDateFormat
public void set(T value) {
   //得到当前线程，保证隔离性
    Thread t = Thread.currentThread();
    //根据线程得到ThreadLocalMap，没有初始化则进行初始化
    ThreadLocalMap map = getMap(t);
    //如果map不为空，则将值set进去
    if (map != null)
        map.set(this, value);
    else   //否则的话创建map
        createMap(t, value);
}



TheadLocalMap中的Entry是这样的
static class Entry extends WeakReference<ThreadLocal<?>> {
    Object value;
     
    Entry(ThreadLocal k, Object v) {
        super(k);
        value = v;
    }
}

实际上一开始我看到这个代码我感觉有点奇怪的
因为我印象中认为WeakReference应该是这样用的
WeakReference<Integer> dd = 23;
dd.get();
我没想到定义一个类还可以去继承WeakReference  
有点奇怪哦。。




注意一般来说我们ThreadLocal是定义成属性成员变量的 这也意味着他是分配在堆内存上的
之前一直没想过对于属性成员变量指向的内存如何回收
现在一想 应该是只需要给他赋值为null 也就是没有引用指向原来那块内存 这也垃圾回收器就会回收了
问题回到ThreadLocal这里 加入线程运行完了 我需要回收ThreadLocal所对应的内存 怎么办？
当我们在业务代码中执行了 ThreadLocal dateformate = null 操作，表示我们想要清理掉这个 ThreadLocal 实例

所以问题来了，业务代码的ThreadLocal引用已经指向Null了，但是ThreadLocalMap还有引用是指向ThreadLocal内存的 因为他是作为Key存在的
如果我们需要回收的话，我们只需要把Key设置为弱引用
同时ThreadLocal会把这个Entry一直在数组里占着是不行的，所以会把key==null的 value 给清理掉。
value不能设置为弱应用 不然用着用着value给回收掉了就尴尬了。。。




ThreadLocal的使用场景
候选者：Spring事务管理就是用的ThreadLocal来实现，ThreadLocal存储的类型是一个Map
ThreadLocal<Map<DataSource,Connection>> resource
候选者：Map中的key 是DataSource，value 是Connection（为了应对多数据源的情况，所以是一个Map）
相当于每个线程都有自己的连接对象 保证事务在同一个连接对象中完成。
用了ThreadLocal保证了同一个线程获取一个Connection对象，从而保证一次事务的所有操作需要在同一个数据库连接上。





内存泄露/remove()方法
首先说下用完ThreadLocal一定要调用remove()方法！一定要调用remove()方法！一定要调用remove()方法！ 否则就是会造成内存泄露。
内存泄漏指的是，当某一个对象不再有用的时候，占用的内存却不能被回收，这就叫作内存泄漏。