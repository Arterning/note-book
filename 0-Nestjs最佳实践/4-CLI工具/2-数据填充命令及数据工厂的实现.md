æ•°æ®å¡«å……å‘½ä»¤åŠæ•°æ®å·¥å‚çš„å®ç°
## è¯¾å‰å‡†å¤‡
è¯·é˜…è¯»ä»¥ä¸‹æ–‡æ¡£

- [dayjså®˜ç½‘æ–‡æ¡£](https://day.js.org/zh-CN/)
- [fakerjså®˜ç½‘æ–‡æ¡£](https://fakerjs.dev/guide/)
## é¢„è£…ç±»åº“

- `dayjs`: ä¸€ä¸ªæ—¶é—´åº“
- `faker`: ä¸€ä¸ªå‡æ•°æ®ç”Ÿæˆåº“
```bash
~ pnpm add @faker-js/faker dayjs
```
## å·¥å…·å‡½æ•°
### æ—¶é—´å‡½æ•°
ä¸ºäº†å¯ä»¥å¿«æ·çš„è·å–`dayjs`çš„æ—¶é—´å¯¹è±¡ï¼Œæˆ‘ä»¬æ·»åŠ ä¸€ä¸ªæ—¶é—´å‡½æ•°
é¦–å…ˆå®šä¹‰ä¸€ä¸ªæ—¶é—´å‚æ•°é€‰é¡¹ç±»å‹

- `date`: æ—¶é—´å±æ€§ï¼Œå¦‚æœä¸ä¼ å…¥åˆ™è·å–å½“å‰å±æ€§
- `format`: è¾“å‡ºæ—¶é—´æ ¼å¼ï¼Œå…·ä½“å¯ä»¥å‚è€ƒdayjsçš„æ–‡æ¡£
- `locale`: è¯­è¨€ï¼Œå¦‚æœä¸ä¼ å…¥åˆ™ä½¿ç”¨`app`é…ç½®ä¸­è®¾ç½®çš„é»˜è®¤è¯­è¨€
- `strict`: æ˜¯å¦å¼€å¯ä¸¥æ ¼æ¨¡å¼
- `zonetime`: æ—¶åŒºã€‚å¦‚æœä¸ä¼ å…¥åˆ™ä½¿ç”¨`app`é…ç½®ä¸­è®¾ç½®çš„é»˜è®¤æ—¶åŒº
```typescript
// src/modules/core/types.ts
export interface TimeOptions {
    date?: dayjs.ConfigType;
    format?: dayjs.OptionType;
    locale?: string;
    strict?: boolean;
    zonetime?: string;
}
```
å‡½æ•°æ¥æ”¶ä¸€ä¸ªé€‰é¡¹å‚æ•°å¹¶æœ€ç»ˆè¿”å›ä¸€ä¸ªdayjså¯¹è±¡ï¼Œæ‰§è¡Œé€»è¾‘å¦‚ä¸‹

1. ä»ä¼ å…¥çš„é€‰é¡¹å‚æ•°ä¸­è·å–å¿…è¦çš„å±æ€§
2. è·å–åº”ç”¨é…ç½®ä¸­çš„é»˜è®¤æ—¶åŒºåŠè¯­è¨€ç›¸å…³é…ç½®
3. å…‹éš†ä¸€ä¸ªæ–°çš„dayjså¯¹è±¡
4. è¿”å›è¯¥å¯¹è±¡å¹¶è®¾ç½®æ—¶åŒº
```typescript
// src/modules/core/helpers/utils.ts	
...
dayjs.extend(localeData);
dayjs.extend(utc);
dayjs.extend(timezone);
dayjs.extend(advancedFormat);
dayjs.extend(customParseFormat);
dayjs.extend(dayOfYear);

export const getTime = async (options?: TimeOptions) => {
    const { date, format, locale, strict, zonetime } = options ?? {};
    const config = await App.configure.get<AppConfig>('app');
    // æ¯æ¬¡åˆ›å»ºä¸€ä¸ªæ–°çš„æ—¶é—´å¯¹è±¡
    // å¦‚æœæ²¡æœ‰ä¼ å…¥localæˆ–timezoneåˆ™ä½¿ç”¨åº”ç”¨é…ç½®
    const now = dayjs(date, format, locale ?? config.locale, strict).clone();
    return now.tz(zonetime ?? config.timezone);
};
```
### å…¶å®ƒå‡½æ•°

- `getRandomIndex`: ç”¨äºè·å–å°äºNçš„ä¸€ä¸ªéšæœºæ•´æ•°
- `getRandItemData`: ç”¨äºä»ä¸€ä¸ªå¯¹è±¡æ•°ç»„ä¸­è·å–ä¸€ä¸ªéšæœºé¡¹
- `getRandListData`: ä»ä¸€ä¸ªå¯¹è±¡æ•°ç»„ä¸­è·å–å¤šä¸ªéšæœºé¡¹ç»„æˆä¸€ä¸ªæ–°æ•°ç»„
```typescript
// src/modules/core/helpers/utils.ts
export const getRandomIndex = (count: number) => Math.floor(Math.random() * count);

export const getRandItemData = <T extends Record<string, any>>(list: T[]) => {
    return list[getRandomIndex(list.length)];
};

export const getRandListData = <T extends Record<string, any>>(list: T[]) => {
    const result: T[] = [];
    for (let i = 0; i < getRandomIndex(list.length); i++) {
        const random = getRandItemData<T>(list);
        if (!result.find((item) => item.id === random.id)) {
            result.push(random);
        }
    }
    return result;
};
```
## æ•°æ®å¡«å……
### è¾…åŠ©å‡½æ•°
æ·»åŠ ä¸€ä¸ªè¾…åŠ©å‡½æ•°ç”¨äºæ ¹æ®æ•°æ®é…ç½®åç§°è·å–ä¸€ä¸ªæ•°æ®åº“è¿æ¥é…ç½®
> ä¸æ—¶é—´å‡½æ•°ä¸€æ ·ï¼Œå¯ä»¥é€šè¿‡`App`çš„é™æ€å±æ€§`configure`æ¥è·å–æ•°æ®åº“é…ç½®ï¼Œå†æ¬¡ä½“éªŒåˆ°è¯¾ç¨‹é…ç½®ç³»ç»Ÿçš„å¼ºå¤§äº†å§ ~ LOL

```typescript
// src/modules/database/helpers.ts
export async function getDbConfig(cname = 'default') {
    const { connections = [] }: DbConfig = await App.configure.get<DbConfig>('database');
    const dbConfig = connections.find(({ name }) => name === cname);
    if (isNil(dbConfig)) panic(`Database connection named ${cname} not exists!`);
    return dbConfig as TypeormOption;
}
```
### åŸºç¡€ç±»
åŸºç¡€ç±»æ˜¯æ‰€æœ‰Seederç±»çš„åŸºç±»ï¼Œç”šè‡³æ˜¯Seederå…¥å£å¯åŠ¨ç±»çš„åŸºç±»
**æˆ‘ä»¬çš„é€»è¾‘æ˜¯é€šè¿‡ä¸€ä¸ªSeederå…¥å£ç±»çš„**`**call**`**æ–¹æ³•æ¥è°ƒç”¨å…¶å®ƒæ‰€æœ‰çš„å­Seederï¼Œè€Œåœ¨å­Seederçš„**`**run**`**æ–¹æ³•å†…ç¼–å†™æ•°æ®å¡«å……é€»è¾‘**
#### ç±»å‹
ç¼–å†™ä¹‹å‰æˆ‘ä»¬å…ˆæ·»åŠ ä»¥ä¸‹ç±»å‹
`SeederOptions`æ˜¯æ•°æ®å¡«å……å¤„ç†å™¨é€‰é¡¹

- `connection`ç±»å‹ä¸ºæ•°æ®åº“è¿æ¥åç§°
- `transaction`ç”¨äºè®¾ç½®æ˜¯å¦é€šè¿‡äº‹åŠ¡æ¥è¿è¡Œå¡«å……

`SeederLoadParams`ç”¨äºè®¾ç½®`load`æ–¹æ³•çš„ï¼ˆå¡«å……æ•°æ®é€»è¾‘æ–¹æ³•ï¼‰çš„å‚æ•°ç±»å‹ï¼Œå…¶å±æ€§å¦‚ä¸‹

- `connection`ï¼šè¿æ¥åç§°
- `dataSource`: æ•°æ®è¿æ¥æ± 
- `em`: Â EntityManagerå®ä¾‹
- `configure`: é…ç½®ç±»å®ä¾‹

`SeederConstructor`ä¸º`call`æ–¹æ³•çš„å‚æ•°ç±»å‹ï¼Œç”¨äºä¼ å…¥Seedå­ç±»æ¥è¿è¡Œå¡«å……
```typescript
// src/modules/database/types.ts
export interface SeederOptions {
    connection?: string;
    transaction?: boolean;
}


export interface SeederLoadParams {
    connection: string;
    dataSource: DataSource;
    em: EntityManager;
    configure: Configure;
}

export interface SeederConstructor {
    new (spinner: Ora, args: SeederOptions): Seeder;
}
```
#### å±æ€§
ä»¥ä¸‹æ˜¯è¯¥ç±»çš„å±æ€§

- `dataSource`å±æ€§: æ•°æ®è¿æ¥æ± 
- `em`å±æ€§: entity manager
- `configure`å±æ€§: é…ç½®ç±»çš„å®ä¾‹
- `truncates`å±æ€§: åœ¨æ‰§è¡ŒSeedæ—¶éœ€è¦æ¸…ç©ºçš„æ•°æ®è¡¨å¯¹åº”çš„æ¨¡å‹ç±»
#### `load`æ–¹æ³•
è¯¥æ–¹æ³•çš„æ‰§è¡Œé€»è¾‘ä¸º

1. è®¾ç½®æ•°æ®åº“è¿æ¥åï¼Œè¿æ¥æ± ï¼Œemï¼Œé…ç½®ç±»å®ä¾‹
2. åˆ¤æ–­å½“å‰è¿è¡Œç¯å¢ƒæ˜¯å¦ä¸ºç”Ÿäº§ç¯å¢ƒ
3. å¦‚æœä¸æ˜¯åœ¨ç”Ÿäº§ç¯å¢ƒä¸‹ï¼Œåˆ™åœ¨è¿è¡Œå¡«å……ä¹‹å‰å…ˆæ ¹æ®`truncates`å±æ€§æŠŠåŸæ¥çš„æ•°æ®è¡¨ä¸­çš„æ•°æ®ç»™æ¸…ç©ºæ‰
4. è°ƒç”¨`run`æ–¹æ³•è¿è¡Œè¿ç§»
#### `run`æ–¹æ³•
è¿™é‡Œæ”¾ç½®å¡«å……æ•°æ®çš„å…·ä½“æ‰§è¡Œé€»è¾‘ï¼Œç›®å‰åªæ¥æ”¶`dataSource`å’Œ`em`ä¸¤ä¸ªå‚æ•°ï¼Œç­‰ä¼šå„¿æˆ‘ä»¬ä¼šæ·»åŠ `factories`å‚æ•°ç”¨äºè·å–è™šæ‹Ÿæ•°æ®
`call`æ–¹æ³•
åœ¨æ­¤æ–¹æ³•å†…è°ƒç”¨å­Seeder.
```typescript
// src/modules/database/base/seeder.ts
export abstract class BaseSeeder implements Seeder {
    protected dataSource: DataSource;

    protected em: EntityManager;

    protected connection: string;

    protected configure: Configure;

    protected truncates: EntityTarget<ObjectLiteral>[] = [];

    constructor(protected readonly spinner: Ora, protected readonly args: SeederOptions) {}

    /**
     * æ¸…ç©ºåŸæ•°æ®å¹¶é‡æ–°åŠ è½½æ•°æ®
     * @param param0
     */
    async load({ dataSource, em, connection, configure }: SeederLoadParams): Promise<any> {
        this.connection = connection;
        this.dataSource = dataSource;
        this.em = em;
        this.configure = configure;
        if (this.configure.getRunEnv() !== EnvironmentType.PRODUCTION) {
            for (const truncate of this.truncates) {
                await this.em.clear(truncate);
            }
        }

        const result = await this.run(this.dataSource);
        return result;
    }

    /**
     * è¿è¡Œseederçš„å…³é”®æ–¹æ³•
     * @param dataSource
     * @param em
     */
    protected abstract run(dataSource?: DataSource, em?: EntityManager): Promise<any>;

    /**
     * è¿è¡Œå­seeder
     *
     * @param SubSeeder
     */
    protected async call(SubSeeder: SeederConstructor) {
        const subSeeder: Seeder = new SubSeeder(this.spinner, this.args);
        await subSeeder.load({
            connection: this.connection,
            dataSource: this.dataSource,
            em: this.em,
            configure: this.configure,
        });
    }
}
```
### å…¥å£ç±»
å…¥å£ç±»ä¸€èˆ¬æ˜¯å”¯ä¸€çš„ï¼Œç”¨äºè°ƒç”¨å…¶å®ƒç¼–å†™å…·ä½“é€»è¾‘çš„Seederç±»æ¥è¿›è¡Œæ•°æ®å¡«å……ï¼Œå…¶é€»è¾‘å¦‚ä¸‹

1. è·å–éœ€è¦è¿è¡Œçš„æ•°æ®è¿æ¥ä¸‹çš„æ‰€æœ‰Seederç±»
2. åˆ¤æ–­å½“å‰ç¯å¢ƒæ˜¯å¦ä¸ºç”Ÿäº§ç¯å¢ƒï¼Œå¦‚æœä¸æ˜¯ï¼Œåˆ™ç›´æ¥éå†è¿è¡Œæ‰€æœ‰Seederç±»ï¼Œå¦‚æœæ˜¯ç”Ÿäº§ç¯å¢ƒåˆ™æŒ‰ä¸‹é¢çš„æ­¥éª¤è¿è¡Œ
3. é¦–å…ˆè¯»å–é¡¹ç›®çš„å¤–å±‚ç›®å½•ä¸‹çš„`seed-lock.yml`æ–‡ä»¶å†…å®¹ï¼ˆå¦‚æœä¸å­˜åœ¨çš„è¯åˆ™åˆ›å»ºä¸€ä¸ªï¼‰
4. æ¥ç€è¯»å–è¯¥yamlæ–‡ä»¶çš„å†…å®¹åˆ°ä¸€ä¸ªå¯¹è±¡å¹¶æŠŠå®ƒèµ‹å€¼ç»™`locked`
5. è¯¥å¯¹è±¡çš„ç»“æ„ä¸º`{è¿æ¥å: [å·²ç»æ‰§è¡Œè¿‡çš„seederç±»å]}`
6. è·å–å½“å‰è¿æ¥ä¸‹å·²ç»æ‰§è¡Œè¿‡çš„seederç±»å¹¶èµ‹å€¼ç»™`lockNames`
7. ä»å½“å‰å¾…æ‰§è¡Œçš„seederç±»æ•°ç»„ä¸­è¿‡æ»¤æ‰`lockNames`ä¸­çš„seederç±»å¹¶èµ‹å€¼ç»™`seeders`æ•°ç»„å˜é‡ï¼Œé˜²æ­¢è¿™äº›seederç±»è¢«é‡å¤æ‰§è¡Œ
8. éå†æ‰§è¡Œ`seeders`æ•°ç»„ä¸­çš„seederç±»
9. å…¨éƒ¨æ‰§è¡Œå®Œæ¯•åæŠŠ`seeders`æ•°ç»„ä¸­çš„ç±»æ·»åŠ åˆ°`locked`å˜é‡
10. æœ€åæŠŠæ–°çš„`locked`å†™å…¥`seed-lock.yml`
```typescript
// src/modules/database/resolver/seed.resolver.ts
export class SeedResolver extends BaseSeeder {
    public async run(_dataSource: DataSource): Promise<any> {
        let seeders: Type<any>[] = ((await getDbConfig(this.connection)) as any).seeders ?? [];
        if (this.configure.getRunEnv() === EnvironmentType.PRODUCTION) {
            const seedLockFile = resolve(__dirname, '../../../..', 'seed-lock.yml');
            ensureFileSync(seedLockFile);
            const yml = YAML.parse(readFileSync(seedLockFile, 'utf8'));
            const locked = isNil(yml) ? {} : yml;
            const lockNames = get<string[]>(locked, this.connection, []).reduce<string[]>(
                (o, n) => (o.includes(n) ? o : [...o, n]),
                [],
            );
            seeders = seeders.filter((s) => !lockNames.includes(s.name));
            for (const seeder of seeders) {
                await this.call(seeder);
            }
            set(locked, this.connection, [
                ...lockNames.filter((n) => !isNil(n)),
                ...seeders.map((s) => s.name).filter((n) => !isNil(n)),
            ]);
            writeFileSync(seedLockFile, JSON.stringify(locked, null, 4));
        } else {
            for (const seeder of seeders) {
                await this.call(seeder);
            }
        }
    }
}
```
## æ•°æ®å·¥å‚
åœ¨è¿è¡Œè¿ç§»æ—¶ï¼Œå¯èƒ½æˆ‘ä»¬æ‰‹å¤´çš„çœŸå®æ•°æ®ä¸å¤Ÿå¤šï¼Œè¿™æ—¶ä½¿ç”¨æ•°æ®å·¥å‚ç”Ÿæˆä¸€æ¡æˆ–å¤šæ¡æ¨¡æ‹Ÿçš„å‡æ•°æ®æ˜¯éå¸¸ä¸é”™çš„åŠæ³•
### å®šä¹‰å‡½æ•°
ç¼–å†™ä¸€ä¸ªå·¥å‚å®šä¹‰å‡½æ•°`defineFactory`ï¼Œè¯¥å‡½æ•°æ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼Œåˆ†åˆ«ä¸ºæ¨¡å‹ç±»å’Œå…¶ç»‘å®šçš„å·¥å‚å‡½æ•°ï¼Œå…¶ä¸­å·¥å‚å‡½æ•°ç”¨äºç¼–å†™ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®çš„é€»è¾‘
`defineFactory`å‡½æ•°çš„è¿”å›å€¼æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å€¼å‡½æ•°çš„ä½œç”¨å°±åœ¨äºæ‰§è¡Œæ—¶ä¼šç”Ÿæˆä¸€ä¸ªæ¨¡å‹å’Œå·¥å‚å‡½æ•°çš„å¯¹è±¡

- `defineFactory`å‡½æ•°çš„ç±»å‹ä¸º`DefineFactory`
- å…¶`handler`å‚æ•°ï¼ˆå·¥å‚å‡½æ•°ï¼‰çš„ç±»å‹ä¸º`DbFactoryHandler`ï¼Œè¯¥å‡½æ•°æ¥æ”¶ä¸¤ä¸ªå‚æ•°`faker`å¯¹è±¡ä»¥åŠè‡ªå®šä¹‰é€‰é¡¹ï¼Œå¹¶è¿”å›ä¸€ä¸ªèµ‹å€¼æ¨¡æ‹Ÿæ•°æ®åçš„æ¨¡å‹å¯¹è±¡
- `defineFactory`çš„è¿”å›å€¼å‡½æ•°æ‰§è¡Œåçš„è¿”å›å€¼ä¸º`DbFactoryOption`ç±»å‹ï¼Œä»–æ˜¯ä¸€ä¸ªæ‹¥æœ‰`entity`æ¨¡å‹ç±»ä»¥åŠ`handler`å·¥å‚å‡½æ•°çš„å¯¹è±¡
```typescript
// src/modules/database/types.ts

export type DbFactoryHandler<E, O> = (faker: Faker, options: O) => Promise<E>;

export type DbFactoryOption<E, O> = {
    entity: ObjectType<E>;
    handler: DbFactoryHandler<E, O>;
};

export type DefineFactory = <E, O>(
    entity: ObjectType<E>,
    handler: DbFactoryHandler<E, O>,
) => () => DbFactoryOption<E, O>;
```
å‡½æ•°çš„ç¼–å†™éå¸¸ç®€å•ï¼Œå¦‚ä¸‹
```typescript
// src/modules/database/helpers.ts
export const defineFactory: DefineFactory = (entity, handler) => () => ({
    entity,
    handler,
});
```
æœ‰äº†è¯¥å‡½æ•°åï¼Œå°±èƒ½é€šè¿‡ä»¥ä¸‹æ–¹å¼æ¥ç»‘å®šæ¨¡å‹å’Œå·¥å‚å‡½æ•°äº†
```typescript
// src/database/factories/content.factory.ts
export const ContentFactory = defineFactory(
    PostEntity,
    async (faker: Faker, options: IPostFactoryOptions) => {
        const post = new PostEntity();
        ...
        return post;
    },
);
```
### æ•°æ®ç”Ÿäº§
æ•°æ®ç”Ÿäº§ç”¨æ¥ç”Ÿäº§æ¨¡æ‹Ÿæ•°æ®
#### `mapFunction`å±æ€§
`mapFunction`å±æ€§ç”¨äºè®¾ç½®å½“å‰éœ€è¦æ‰§è¡Œçš„æ¨¡å‹çš„å·¥å‚å‡½æ•°
#### æ„é€ æ–¹æ³•
æ„é€ æ–¹æ³•æ¥æ”¶å››ä¸ªå‚æ•°

- `name`ä¸ºæ¨¡å‹çš„ç±»åç§°
- `entity`ä¸ºæ¨¡å‹ç±»
- `em`ä¸ºentityManagerå®ä¾‹
- `factory`ä¸ºè¯¥æ¨¡å‹ç»‘å®šçš„factoryæ‰§è¡Œå‡½æ•°ï¼ˆå³æ¨¡æ‹Ÿæ•°æ®ç”Ÿæˆå™¨ï¼‰
- `settings`ä¸ºè®¾ç½®é€‰é¡¹ï¼Œå…¶ç±»å‹ä¸º`DbFactoryOption`
#### `map`æ–¹æ³•
é»˜è®¤çš„æ‰§è¡Œå‡½æ•°æ˜¯å®šä¹‰ååœ¨`database`çš„é…ç½®é‡Œè®¾ç½®äº†çš„ï¼Œä½†æœ‰æ—¶æˆ‘ä»¬å¯ä»¥ä¸æƒ³ä½¿ç”¨é»˜è®¤çš„æ¨¡å‹ç»‘å®šçš„å·¥å‚å‡½æ•°ï¼ŒçŸ¥è¯†åå¯ä»¥é€šè¿‡`map`æ–¹æ³•ä¸ºè¯¥æ¨¡å‹ä¸´æ—¶æ¢ç»‘ä¸€ä¸ªå·¥å‚å‡½æ•°
#### æ¨¡æ‹Ÿä¸åˆ›å»ºæ•°æ®
`make`æ–¹æ³•ç”¨äºä¸´æ—¶åˆ›å»ºä¸€æ‰¹æ¨¡æ‹Ÿæ•°æ®ä»¥å¤‡åç»­ä½¿ç”¨ï¼Œä½†ä¸æ˜¯é©¬ä¸Šå°±å­˜å‚¨åˆ°æ•°æ®åº“
> `this.factory`ç”±æ„é€ å‡½æ•°ä¼ å…¥ï¼Œå®ƒå°±æ˜¯é€šè¿‡ä¸Šé¢çš„`defineFactory`å‡½æ•°è¿”å›çš„å‡½æ•°å†æ‰§è¡Œåè¿”å›çš„å¯¹è±¡ä¸­çš„`handler`å·¥å‚å‡½æ•°ï¼Œæ¯”å¦‚`async (faker: Faker, options: IPostFactoryOptions) => {... return post}`ï¼Œå…·ä½“æ€ä¹ˆå¾—åˆ°è¿™ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬æ¥ä¸‹å»çœ‹ï¼Œè¿™é‡Œå…ˆä¸ç®¡

è¯¥æ–¹æ³•çš„é€»è¾‘å¦‚ä¸‹

1. é¦–å…ˆé€šè¿‡`this.factory`å¾—å‡ºèµ‹å€¼æ¨¡æ‹Ÿæ•°æ®åçš„æ¨¡å‹å¯¹è±¡
2. åœ¨æŠŠä½ è¦é€šè¿‡`overrideParams`å‚æ•°è‡ªå®šä¹‰è¦†ç›–çš„æ¨¡å‹å­—æ®µå€¼è®¾ç½®ä¸€ä¸‹
3. æœ€åè¿”å›è¯¥æ¨¡å‹å®ä¾‹

`create`æ–¹æ³•éå¸¸ç®€å•ï¼Œå°±æ˜¯å…ˆè°ƒç”¨`make`æ–¹æ³•ç”Ÿæˆæ¨¡å‹å¯¹è±¡ï¼Œå†é€šè¿‡entityMangerè·å–è¯¥å¯¹è±¡é»˜è®¤çš„Repositoryå¯¹è±¡ï¼Œç„¶åä½¿ç”¨`save`æ–¹æ³•ä¿å­˜è¯¥å¯¹è±¡ã€‚
äºæ­¤åŒæ—¶ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡ä¼ å…¥ä¸€ä¸ª`existsCheck`æ¥åˆ¤æ–­æ•°æ®åº“ä¸­æ˜¯å¦å­˜åœ¨å½“å‰æ¨¡å‹å®ä¾‹çš„æŸä¸ªå­—æ®µå€¼çš„æ•°æ®ï¼Œå¦‚æœä¸å­˜åœ¨æ‰åˆ›å»ºï¼
#### å¤šæ¡æ•°æ®
é€šè¿‡`makeMany`ä¸`createMany`æ–¹æ³•å¯ä»¥éå†åœ°æ¨¡æ‹ŸåŠåˆ›å»ºå¤šæ¡æ•°æ®ï¼Œæ•°æ®çš„æ•°é‡å¯é€šè¿‡`amount`å‚æ•°æ¥æŒ‡å®š
```typescript
// src/modules/database/types.ts

/**
 * Factoryè‡ªå®šä¹‰å‚æ•°è¦†ç›–
 */
export type FactoryOverride<Entity> = {
    [Property in keyof Entity]?: Entity[Property];
};

// src/modules/database/resolver/factory.resolver.ts
export class FactoryResolver<Entity, Settings> {
    private mapFunction!: (entity: Entity) => Promise<Entity>;
    constructor(
        public name: string,
        public entity: EntityTarget<Entity>,
        protected readonly em: EntityManager,
        private readonly factory: DbFactoryHandler<Entity, Settings>,
        private readonly settings: Settings,
    ) {}
    
    map(mapFunction: (entity: Entity) => Promise<Entity>): FactoryResolver<Entity, Settings> {
        this.mapFunction = mapFunction;
        return this;
    }

    async make(overrideParams: FactoryOverride<Entity> = {}): Promise<Entity> {
        if (this.factory) {
            let entity: Entity = await this.resolveEntity(await this.factory(faker, this.settings));
            if (this.mapFunction) entity = await this.mapFunction(entity);
            for (const key in overrideParams) {
                if (overrideParams[key]) {
                    entity[key] = overrideParams[key]!;
                }
            }
            return entity;
        }
        throw new Error('Could not found entity');
    }

    async create(
        overrideParams: FactoryOverride<Entity> = {},
        existsCheck?: string,
    ): Promise<Entity> {
        try {
            const entity = await this.make(overrideParams);
            if (!isNil(existsCheck)) {
                const repo = this.em.getRepository(this.entity);
                const value = (entity as any)[existsCheck];
                if (!isNil(value)) {
                    const item = await repo.findOneBy({ [existsCheck]: value } as any);
                    if (isNil(item)) return await this.em.save(entity);
                    return item;
                }
            }
            return await this.em.save(entity);
        } catch (error) {
            const message = 'Could not save entity';
            panic({ message, error });
            throw new Error(message);
        }
    }


    async makeMany(
        amount: number,
        overrideParams: FactoryOverride<Entity> = {},
    ): Promise<Entity[]> {
        const list = [];
        for (let index = 0; index < amount; index += 1) {
            list[index] = await this.make(overrideParams);
        }
        return list;
    }

    async createMany(
        amount: number,
        overrideParams: FactoryOverride<Entity> = {},
        existsCheck?: string,
    ): Promise<Entity[]> {
        const list = [];
        for (let index = 0; index < amount; index += 1) {
            list[index] = await this.create(overrideParams, existsCheck);
        }
        return list;
    }

    /**
     * æ ¹æ®Entityè§£æå‡ºå…¶å®šä¹‰çš„å¤„ç†å™¨
     * @param entity
     */
    private async resolveEntity(entity: Entity): Promise<Entity> {
        for (const attribute in entity) {
            if (entity[attribute]) {
                if (isPromise(entity[attribute])) {
                    entity[attribute] = await Promise.resolve(entity[attribute]);
                }

                if (typeof entity[attribute] === 'object' && !(entity[attribute] instanceof Date)) {
                    const subEntityFactory = entity[attribute];
                    try {
                        if (typeof (subEntityFactory as any).make === 'function') {
                            entity[attribute] = await (subEntityFactory as any).make();
                        }
                    } catch (error) {
                        const message = `Could not make ${(subEntityFactory as any).name}`;
                        panic({ message, error });
                        throw new Error(message);
                    }
                }
            }
        }
        return entity;
    }
}
```
### ä¿®æ”¹Seeder
æ¨¡æ‹Ÿæ•°æ®çš„ç”Ÿæˆæœ€ç»ˆç›®çš„æ˜¯æä¾›ç»™æ•°æ®å¡«å……ä½¿ç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¿®æ”¹seederç›¸å…³çš„ä¸€äº›ä¸œè¥¿æ‰å¯ä»¥ä½¿ç”¨æ•°æ®å·¥å‚
#### ç±»å‹
ä¿®æ”¹`SeederLoadParams`ç±»å‹ï¼Œä»¥ä½¿Seederç±»çš„`load`å‡½æ•°çš„å‚æ•°èƒ½æ¥æ”¶æ•°æ®å·¥å‚çš„è§£æå™¨å’Œå¤„ç†å™¨åˆ—è¡¨
```typescript
// src/modules/database/types.ts

/**
 * æ•°æ®å¡«å……å‡½æ•°æ˜ å°„å¯¹è±¡
 */
export type FactoryOptions = {
    [entityName: string]: DbFactoryOption<any, any>;
};

// src/modules/database/types.ts
export interface SeederLoadParams {
    /**
     * Factoryè§£æå™¨
     */
    factorier?: DbFactory;
    /**
     * Factoryå‡½æ•°åˆ—è¡¨
     */
    factories: FactoryOptions;
    ...
}
```
#### å·¥å‚å‡½æ•°
`entityName`å‡½æ•°æ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯é€šè¿‡æ¨¡å‹çš„ç±»åæˆ–å‡½æ•°åæ¥è·å–è¿™ä¸ªæ¨¡å‹çš„åç§°
`factoryBuilder`å‡½æ•°ç”¨äºè¿”å›ä¸€ä¸ªäºŒçº§æŸ¯é‡ŒåŒ–çš„å‡½æ•°ï¼Œè¿”å›çš„å‡½æ•°æœ€ç»ˆç”Ÿæˆä¸€ä¸ªç”¨äºç”Ÿäº§æ•°æ®çš„`FactoryResolver`å®ä¾‹ã€‚å®ƒæ¥æ”¶è¿ä¸ªå‚æ•°ï¼Œå³`dataSource`(æ•°æ®è¿æ¥æ± )ä»¥åŠ`factories`(æ•°æ®å·¥ç¨‹åˆ—è¡¨ï¼Œåœ¨æ‰§è¡Œå¡«å……å‘½ä»¤æ—¶ç”±å‘½ä»¤å¤„ç†å™¨ä¼ å…¥)

```typescript
// src/modules/database/helpers.ts
export function entityName<T>(entity: EntityTarget<T>): string {
    if (entity instanceof Function) return entity.name;
    if (!isNil(entity)) return new (entity as any)().constructor.name;
    throw new Error('Enity is not defined');
}

export const factoryBuilder: DbFactoryBuilder =
    (dataSource, factories) => (entity) => (settings) => {
        const name = entityName(entity);
        if (!factories[name]) {
            throw new Error(`has none factory for entity named ${name}`);
        }
        return new FactoryResolver(
            name,
            entity,
            dataSource.createEntityManager(),
            factories[name].handler,
            settings,
        );
    };
```
#### åŸºç¡€ç±»
ç°åœ¨æˆ‘ä»¬æ¥æ›´æ”¹ä¸€ä¸‹Seederçš„åŸºç±»

- æ›´æ”¹`load`å‡½æ•°ä»¥æ¥æ”¶`factorier`ï¼ˆè¯¥å‚æ•°çš„å€¼å³ä¸Šè¿°çš„`factoryBuilder`å‡½æ•°æ‰§è¡Œåçš„è¿”å›å€¼ï¼‰ä»¥åŠ`factories`å·¥å‚åˆ—è¡¨
- `run`å‡½æ•°æ·»åŠ ä¸€ä¸ª`factorier`å‚æ•°
- ä¿®æ”¹`call`ï¼Œåœ¨æ‰§è¡Œå­ç±»çš„`load`æ—¶é€ä¼ `factorier`å’Œ`factories`çš„å€¼
```typescript
// src/modules/database/base/seeder.ts

/**
 * æ•°æ®å¡«å……åŸºç±»
 */
export abstract class BaseSeeder implements Seeder {

    protected factories!: {
        [entityName: string]: DbFactoryOption<any, any>;
    };

    async load({
        factorier,
        factories,
        dataSource,
        em,
        connection,
        configure,
    }: SeederLoadParams): Promise<any> {
      ...

        const result = await this.run(factorier, this.dataSource);
        return result;
    }

    protected abstract run(
        factorier?: DbFactory,
        dataSource?: DataSource,
        em?: EntityManager,
    ): Promise<any>;

    protected async call(SubSeeder: SeederConstructor) {
        const subSeeder: Seeder = new SubSeeder(this.spinner, this.args);
        await subSeeder.load({
            connection: this.connection,
            factorier: factoryBuilder(this.dataSource, this.factories),
            factories: this.factories,
            dataSource: this.dataSource,
            em: this.em,
            configure: this.configure,
        });
    }
}
```
## ç¼–å†™å‘½ä»¤
æ¥ä¸‹æ¥æˆ‘ä»¬ç¼–å†™ä¸€äº›å…·ä½“çš„æ•°æ®å¡«å……å‘½ä»¤
### å¿½ç•¥å¤–é”®
åœ¨æ¸…ç©ºæ•°æ®æ—¶ï¼Œä½¿ç”¨å¤–é”®å…³è”æ•°æ®ä¼šå¯¼è‡´è‡´å‘½é”™è¯¯ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å¿½ç•¥å¤–é”®
> åœ¨æ¸…ç©ºå¤–å®Œæ¯•åè¯·é‡æ–°å…³é—­å¿½ç•¥

```typescript
// src/modules/database/helpers.ts

export async function resetForeignKey(
    em: EntityManager,
    type = 'mysql',
    disabled = true,
): Promise<EntityManager> {
    let key: string;
    let query: string;
    if (type === 'sqlite') {
        key = disabled ? 'OFF' : 'ON';
        query = `PRAGMA foreign_keys = ${key};`;
    } else {
        key = disabled ? '0' : '1';
        query = `SET FOREIGN_KEY_CHECKS = ${key};`;
    }
    await em.query(query);
    return em;
}
```
### ç±»å‹

- åœ¨åŸæ¥çš„`DbAdditionalOption`ç±»å‹ä¸­æ·»åŠ ä¸€ä¸ª`seedRunner`ç±»å‹ï¼Œç”¨äºåœ¨é…ç½®ä¸­æŒ‡å®šè‡ªå®šä¹‰çš„å¡«å……å…¥å£ç±»ï¼Œæ·»åŠ ä¸€ä¸ª`seeders`ç±»å‹ç”¨äºè®¾ç½®å¡«å……ç±»åˆ—è¡¨ï¼Œæ·»åŠ ä¸€ä¸ª`factories`å±æ€§ç”¨äºå®šä¹‰æ•°æ®å·¥å‚åˆ—è¡¨
- æ·»åŠ ä¸€ä¸ª`SeederArguments`ç±»å‹ä½œä¸ºå¡«å……å‘½ä»¤çš„å‚æ•°ç±»å‹
- `DbFactory`ç”¨äºå®šä¹‰`factoryBuilder`å‡½æ•°è¿”å›çš„å·¥å‚å‡½æ•°è·å–å‡½æ•°çš„ç±»å‹
```typescript
// src/modules/database/types.ts

type DbAdditionalOption = {
    seedRunner?: SeederConstructor;
    seeders?: SeederConstructor[];
    factories?: (() => DbFactoryOption<any, any>)[];
    ...
};

export type SeederArguments = TypeOrmArguments & SeederOptions;

export interface DbFactory {
    <Entity>(entity: EntityTarget<Entity>): <Options>(
        options?: Options,
    ) => FactoryResolver<Entity, Options>;
}
```
### å¡«å……æ‰§è¡Œ
è¯¥å‡½æ•°æ˜¯æ•°æ®å¡«å……å‘½ä»¤çš„æ ¸å¿ƒæ‰§è¡Œå‡½æ•°ï¼Œæ¥æ”¶ä»¥ä¸‹å‚æ•°

- `Clazz`: ä¼ å…¥çš„å…¥å£å¡«å……ç±»ï¼Œç”¨äºæ‰§è¡Œå¡«å……å­ç±»
- `args`: å¡«å……å‘½ä»¤çš„é€‰é¡¹å‚æ•°
- `spinner`: Oraå¯¹è±¡ï¼Œå±•ç¤ºâ€œæ‰§è¡Œä¸­â€çš„é›ªç¢§è¿›åº¦åŠ¨ç”»
- `configure`: `Configure`ç±»çš„å®ä¾‹

æ‰§è¡Œé€»è¾‘å¦‚ä¸‹

1. åˆ›å»ºå…¥å£å¡«å……ç±»çš„å®ä¾‹
2. è·å–å½“å‰æ•°æ®åº“è¿æ¥çš„é…ç½®
3. æ ¹æ®é…ç½®åˆ›å»ºå½“å‰æ•°æ®åº“è¿æ¥çš„è¿æ¥æ± 
4. åˆå§‹åŒ–æ•°æ®åº“è¿æ¥æ± 
5. éå†æ•°æ®å·¥å‚å‡½æ•°ç”Ÿæˆæ•°æ®å·¥å‚åˆ—è¡¨å¯¹è±¡ï¼Œæ ¼å¼ä¸º`{æ¨¡å‹å: {æ¨¡å‹ç±»,å¤„ç†å™¨}}`
6. å¦‚æœä¸å¯ç”¨äº‹åŠ¡ï¼Œåˆ™ç›´æ¥è¿è¡Œå¡«å……ç±»å®ä¾‹çš„`load`æ–¹æ³•å¡«å……æ•°æ®ï¼ˆæ³¨æ„ï¼Œéœ€è¦å¿½ç•¥å¤–é”®ï¼‰
7. å¦‚æœå¯ç”¨äº‹åŠ¡(é»˜è®¤å¯ç”¨)ï¼Œåˆ™é€šè¿‡äº‹åŠ¡çš„æ–¹å¼å»å¡«å……æ•°æ®ï¼ˆåŒæ ·éœ€è¦å¿½ç•¥å¤–é”®ï¼‰
8. é”€æ¯æœ¬æ¬¡æ•°æ®åº“è¿æ¥å®ä¾‹
```typescript
// src/modules/database/helpers.ts

export async function runSeeder(
    Clazz: SeederConstructor,
    args: SeederOptions,
    spinner: Ora,
    configure: Configure,
): Promise<DataSource> {
    const seeder: Seeder = new Clazz(spinner, args);
    const dbConfig = await getDbConfig(args.connection);
    const dataSource = new DataSource({ ...dbConfig } as DataSourceOptions);

    await dataSource.initialize();
    const factoryMaps: FactoryOptions = {};
    for (const factory of dbConfig.factories) {
        const { entity, handler } = factory();
        factoryMaps[entity.name] = { entity, handler };
    }
    if (typeof args.transaction === 'boolean' && !args.transaction) {
        const em = await resetForeignKey(dataSource.manager, dataSource.options.type);
        await seeder.load({
            factorier: factoryBuilder(dataSource, factoryMaps),
            factories: factoryMaps,
            dataSource,
            em,
            configure,
            connection: args.connection ?? 'default',
        });
        await resetForeignKey(em, dataSource.options.type, false);
    } else {
        // åœ¨äº‹åŠ¡ä¸­è¿è¡Œ
        const queryRunner = dataSource.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        try {
            const em = await resetForeignKey(queryRunner.manager, dataSource.options.type);
            await seeder.load({
                factorier: factoryBuilder(dataSource, factoryMaps),
                factories: factoryMaps,
                dataSource,
                em,
                configure,
                connection: args.connection ?? 'default',
            });
            await resetForeignKey(em, dataSource.options.type, false);
            // æäº¤äº‹åŠ¡
            await queryRunner.commitTransaction();
        } catch (err) {
            console.log(err);
            // é‡åˆ°é”™è¯¯åˆ™å›æ»š
            await queryRunner.rollbackTransaction();
        } finally {
            // æ‰§è¡Œäº‹åŠ¡
            await queryRunner.release();
        }
    }
    if (dataSource.isInitialized) await dataSource.destroy();
    return dataSource;
}
```
### å¤„ç†å™¨
å‘½ä»¤å¤„ç†å™¨éå¸¸ç®€å•

1. åˆ¤æ–­åœ¨å½“å‰æ•°æ®åº“è¿æ¥çš„é…ç½®ä¸­æœ‰è‡ªå®šä¹‰çš„å¡«å……å…¥å£ç±»ï¼Œæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤çš„`SeedResolver`
2. ä½¿ç”¨`runSeeder`è¿è¡Œå¡«å……
```typescript
// src/modules/database/commands/seed.handler.ts

export const SeedHandler = async (args: SeederOptions, configure: Configure) => {
    const runner = (await getDbConfig(args.connection)).seedRunner ?? SeedResolver;
    const spinner = ora('Start run seeder');
    try {
        spinner.start();
        await runSeeder(runner, args, spinner, configure);
        spinner.succeed(`\n ğŸ‘ ${chalk.greenBright.underline(`Finished Seeding`)}`);
    } catch (error) {
        panic({ spinner, message: `Run seeder failed`, error });
    }
};
```
### å¡«å……å‘½ä»¤
å¡«å……å‘½ä»¤æ¥æ”¶ä¸‰ä¸ªå‚æ•°

- `clear`: æ˜¯å¦æ ¹æ®å¡«å……ç±»ä¸­å®šä¹‰çš„`truncated`å±æ€§æ¸…é™¤æ•°æ®è¡¨ï¼ˆç”Ÿäº§ç¯å¢ƒä¸‹ä¸å¯ç”¨ï¼‰
- `connection`: éœ€è¦è¿è¡Œå¡«å……çš„æ•°æ®åº“è¿æ¥åï¼ˆé»˜è®¤`default`ï¼‰
- `transaction`: æ˜¯å¦åœ¨äº‹åŠ¡æ¨¡å¼ä¸‹è¿è¡Œ
```typescript
// src/modules/database/commands/seed.command.ts

export const SeedCommand: CommandItem<any, SeederArguments> = ({ configure }) => ({
    command: ['db:seed', 'dbs'],
    describe: 'Runs all seeds data.',
    builder: {
        clear: {
            type: 'boolean',
            alias: 'r',
            describe: 'Clear which tables will truncated specified by seeder class.',
            default: true,
        },
        connection: {
            type: 'string',
            alias: 'c',
            describe: 'Connection name of typeorm to connect database.',
        },
        transaction: {
            type: 'boolean',
            alias: 't',
            describe: ' If is seed data in transaction,default is true',
            default: true,
        },
    } as const,

    handler: async (args: yargs.Arguments<SeederArguments>) => SeedHandler(args, configure),
});
```
### ä¿®æ”¹è¿è¡Œè¿ç§»å‘½ä»¤
æˆ‘ä»¬ä¸ä»…å¯ä»¥ä½¿ç”¨`pnpm dbs`å‘½ä»¤å•ç‹¬è¿è¡Œå¡«å……å‘½ä»¤ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥ä¿®æ”¹ä¸€ä¸‹è¿è¡Œè¿ç§»çš„å‘½ä»¤ï¼Œä»¥ä¾¿åœ¨è¿è¡Œè¿ç§»æ—¶ç›´æ¥`pnpm dbmr -s`è¿™ä¸€æ¡å‘½ä»¤å°±å¯ä»¥åŒæ—¶è¿è¡Œè¿ç§»å’Œå¡«å……
```typescript
// src/modules/database/types.ts

export interface MigrationRunOptions extends MigrationRevertOptions {
    ...
    seed?: boolean;
}

    
// src/modules/database/commands/migration-run.command.ts
    
export const RunMigrationCommand: CommandItem<any, MigrationRunArguments> = ({ configure }) => ({
   ...
        seed: {
            type: 'boolean',
            alias: 's',
            describe: 'run seeders after refresh database',
            default: false,
        },
    } as const,
});

// src/modules/database/commands/migration-run.handler.ts

export const MigrationRunHandler = async (
    configure: Configure,
    args: yargs.Arguments<MigrationRunArguments>,
) => {
    ...
    if (args.seed) {
        try {
            spinner.start('Start run seeder');
            const runner = (await getDbConfig(args.connection)).seedRunner ?? SeedResolver;
            await runSeeder(
                runner,
                { connection: args.connection, transaction: true },
                spinner,
                configure,
            );
            spinner.succeed(`\n ğŸ‘ ${chalk.greenBright.underline(`Finished Seeding`)}`);
        } catch (error) {
            if (dataSource && dataSource.isInitialized) await dataSource.destroy();
            panic({ spinner, message: `Run seeder failed`, error });
        }
    }

    if (dataSource && dataSource.isInitialized) await dataSource.destroy();
};
```
## ä½¿ç”¨æ–¹æ³•
æœ€åæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹æ€ä¹ˆå»ä½¿ç”¨å¡«å……å‘½ä»¤
### æ¨¡æ‹Ÿæ•°æ®
é¦–å…ˆæˆ‘ä»¬åˆ©ç”¨æ•°æ®å·¥å‚ç”Ÿæˆä¸€äº›å‡æ•°æ®
> éƒ¨åˆ†æ–‡ç« çš„å†…å®¹æˆ‘ä»¬ç›´æ¥ä½¿ç”¨çœŸå®çš„markdownæ–‡æ¡£ï¼Œè¿™æ ·æ•°æ®æ›´å…·å¯è¯»æ€§

```bash
~ mkdir -p src/assets/posts
```
åœ¨è¯¥ç›®å½•ä¸‹æ–°å¢å‡ ä¸ª`.md`æ–‡ä»¶ç”¨äºå­˜å‚¨æ–‡ç« å†…å®¹
ä¸ºäº†èƒ½åœ¨`pnpm build`ç¼–è¯‘åæŠŠè¿™äº›æ–‡ä»¶å¤åˆ¶åˆ°`dist`ç›®å½•ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æ›´æ”¹ä¸€ä¸‹`nest-cli.json`æ–‡ä»¶ï¼Œå¦‚ä¸‹
```json
{
    "$schema": "https://json.schemastore.org/nest-cli",
    "collection": "@nestjs/schematics",
    "sourceRoot": "src",
    "compilerOptions": {
        "deleteOutDir": true,
        "assets": ["assets"],
        "watchAssets": true
    }
}
```
åŒæ ·åœ°ï¼Œä¸ºäº†æ•°æ®æ›´æ˜¾çœŸå®æ€§ï¼Œæˆ‘ä»¬åœ¨å®šä¹‰çš„æ—¶å€™æ–‡ç« æ ‡é¢˜ï¼Œåˆ†ç±»ç­‰éƒ½ä½¿ç”¨ä¸€éƒ¨åˆ†çœŸå®æ•°æ®
```typescript
// src/database/factories/content.data.ts

export interface PostData {
    title: string;
    contentFile: string;
    summary?: string;
    categories?: string[];
    author?: string;
}

export interface CategoryData {
    name: string;
    children?: CategoryData[];
}

export interface ContentConfig {
    fixture?: {
        categories: CategoryData[];
        posts: PostData[];
    };
}

export const posts: PostData[] = [
    {
        title: 'åŸºäºè§’è‰²å’Œå±æ€§çš„Node.jsè®¿é—®æ§åˆ¶',
        contentFile: 'rbac.md',
        categories: ['node'],
    },
    {
        title: 'dockerç®€ä»‹',
        contentFile: 'docker-introduce.md',
        categories: ['devops'],
    },
    {
        title: 'goåç¨‹å…¥é—¨',
        contentFile: 'goroutings.md',
        categories: ['go'],
        author: 'lige',
    },
    {
        title: 'åŸºäºlerna.jsæ„å»ºmonorepo',
        contentFile: 'lerna.md',
        categories: ['typescript'],
        author: 'xiaoming',
    },
    {
        title: 'é€šè¿‡PHPç†è§£IOCç¼–ç¨‹',
        contentFile: 'php-di.md',
        categories: ['php'],
        author: 'xiaoming',
    },
    {
        title: 'ç©è½¬React Hooks',
        contentFile: 'react-hooks.md',
        categories: ['react'],
        author: 'lige',
    },
    {
        title: 'TypeORM fixtures cliä¸­æ–‡è¯´æ˜',
        contentFile: 'typeorm-fixtures-cli.md',
        categories: ['typescript'],
        author: 'lige',
    },
    {
        title: 'ä½¿ç”¨yargsæ„å»ºnodeå‘½ä»¤è¡Œ(ç¿»è¯‘)',
        contentFile: 'yargs.md',
        categories: ['node'],
    },
    {
        title: 'Typescriptè£…é¥°å™¨è¯¦è§£',
        summary:
            'è£…é¥°å™¨ç”¨äºç»™ç±»,æ–¹æ³•,å±æ€§ä»¥åŠæ–¹æ³•å‚æ•°ç­‰å¢åŠ ä¸€äº›é™„å±åŠŸèƒ½è€Œä¸å½±å“å…¶åŸæœ‰ç‰¹æ€§ã€‚å…¶åœ¨Typescriptåº”ç”¨ä¸­çš„ä¸»è¦ä½œç”¨ç±»ä¼¼äºJavaä¸­çš„æ³¨è§£,åœ¨AOP(é¢å‘åˆ‡é¢ç¼–ç¨‹)ä½¿ç”¨åœºæ™¯ä¸‹éå¸¸æœ‰ç”¨',
        contentFile: 'typescript-decorator.md',
        categories: ['typescript'],
    },
];

export const categories: CategoryData[] = [
    {
        name: 'æŠ€æœ¯æ–‡æ¡£',
        children: [
            {
                name: 'typescript',
                children: [{ name: 'node' }, { name: 'nestjs' }, { name: 'react' }],
            },
            {
                name: 'go',
                children: [{ name: 'gin' }, { name: 'echo' }],
            },
            {
                name: 'php',
                children: [{ name: 'laravel' }],
            },
            {
                name: 'java',
            },
            {
                name: 'python',
            },
            {
                name: 'devops',
            },
        ],
    },
    {
        name: 'éšç¬”è®°å¿†',
        children: [
            {
                name: 'å·¥ä½œå†ç¨‹',
            },
            {
                name: 'ç½‘ç«™æ”¶è—',
            },
        ],
    },
];
```
ä¸‹é¢æˆ‘ä»¬ä¸ºæ–‡ç« æ¨¡å‹å®šä¹‰ä¸€ä¸ªæ•°æ®å·¥å‚ç”¨äºåœ¨çœŸå®æ•°æ®ä¹‹å¤–ç”Ÿæˆä¸€æ‰¹å‡æ•°æ®ï¼Œè¿™å¯¹æµ‹è¯„å‰ç«¯åˆ†é¡µï¼Œè¿˜æœ‰åé¢æˆ‘ä»¬è‡ªå·±çš„ç³»ç»Ÿä¸­å¯èƒ½ä¼šå¼€å‘çš„çƒ­é—¨æ–‡ç« ï¼Œæœ€æ–°æ–‡ç« ç­‰ç­‰åŠŸèƒ½çš„å±•ç¤ºæ•ˆæœéå¸¸æœ‰ç”¨
```typescript
// src/database/factories/content.factory.ts

export type IPostFactoryOptions = Partial<{
    title: string;
    summary: string;
    body: string;
    isPublished: boolean;
    categories: CategoryEntity[];
    comments: CommentEntity[];
}>;
export const ContentFactory = defineFactory(
    PostEntity,
    async (faker: Faker, options: IPostFactoryOptions) => {
        faker.setLocale('zh_CN');
        const post = new PostEntity();
        const { title, summary, body, categories } = options;
        post.title = title ?? faker.lorem.sentence(Math.floor(Math.random() * 10) + 6);
        if (summary) {
            post.summary = options.summary;
        }
        post.body = body ?? faker.lorem.paragraph(Math.floor(Math.random() * 500) + 1);
        post.publishedAt = (await getTime()).toDate();
        if (Math.random() >= 0.5) {
            post.deletedAt = (await getTime()).toDate();
        }
        if (categories) {
            post.categories = categories;
        }
        return post;
    },
);
```
### å¡«å……ç±»
å¡«å……ç±»çœ‹ä¼¼ä»£ç ä¸€å¤§å¨å®åˆ™éå¸¸ç®€å•ç›´ç™½ï¼Œå¯è‡ªè¡Œçœ‹ä¸€ä¸‹ï¼Œå…·ä½“æ¥è¯´æœ‰è¿™ä¹ˆå‡ ç‚¹

- `truncates`å±æ€§: å®šä¹‰åœ¨éç”Ÿäº§ç¯å¢ƒä¸‹è¿è¡Œæ•°æ®å¡«å……å‰éœ€è¦æ¸…ç©ºçš„è¡¨
- `factorier`å±æ€§: é€šè¿‡åœ¨`runSeeder`æ‰§è¡Œ`factoryBuilder`æ‰€å¾—ï¼Œç”¨äºé€šè¿‡æŒ‡å®šæ¨¡å‹å’Œé€‰é¡¹æ¥é€šè¿‡æ•°æ®å·¥å‚ç”Ÿæˆå‡æ•°æ®
- åœ¨`run`ä¸­æ‰§è¡Œå‡æ•°æ®ç”Ÿæˆé€»è¾‘
```typescript
// src/database/seeders/content.seeder.ts

export default class ContentSeeder extends BaseSeeder {
    protected truncates = [PostEntity, CategoryEntity, CommentEntity];

    protected factorier!: DbFactory;

    async run(_factorier: DbFactory, _dataSource: DataSource, _em: EntityManager): Promise<any> {
        this.factorier = _factorier;
        await this.loadCategories(categories);
        await this.loadPosts(posts);
    }

    private async genRandomComments(post: PostEntity, count: number, parent?: CommentEntity) {
        const comments: CommentEntity[] = [];
        for (let i = 0; i < count; i++) {
            const comment = new CommentEntity();
            comment.body = faker.lorem.paragraph(Math.floor(Math.random() * 18) + 1);
            comment.post = post;
            if (parent) {
                comment.parent = parent;
            }
            comments.push(await this.em.save(comment));
            if (Math.random() >= 0.8) {
                comment.children = await this.genRandomComments(
                    post,
                    Math.floor(Math.random() * 2),
                    comment,
                );
                await this.em.save(comment);
            }
        }
        return comments;
    }

    private async loadCategories(data: CategoryData[], parent?: CategoryEntity): Promise<void> {
        let order = 0;
        for (const item of data) {
            const category = new CategoryEntity();
            category.name = item.name;
            category.customOrder = order;
            if (parent) category.parent = parent;
            await this.em.save(category);
            order++;
            if (item.children) {
                await this.loadCategories(item.children, category);
            }
        }
    }

    private async loadPosts(data: PostData[]) {
        const allCates = await this.em.find(CategoryEntity);
        for (const item of data) {
            const filePath = path.join(__dirname, '../../assets/posts', item.contentFile);
            if (!existsSync(filePath)) {
                panic({
                    spinner: this.spinner,
                    message: `post content file ${filePath} not exits!`,
                });
            }
            const options: IPostFactoryOptions = {
                title: item.title,
                body: fs.readFileSync(filePath, 'utf8'),
                isPublished: true,
            };
            if (item.summary) {
                options.summary = item.summary;
            }
            if (item.categories) {
                options.categories = await getCustomRepository(
                    this.dataSource,
                    CategoryRepository,
                ).find({
                    where: { name: In(item.categories) },
                });
            }
            const post = await this.factorier(PostEntity)(options).create();

            await this.genRandomComments(post, Math.floor(Math.random() * 5));
        }
        const redoms = await this.factorier(PostEntity)<IPostFactoryOptions>({
            categories: getRandListData(allCates),
        }).createMany(100);
        for (const redom of redoms) {
            await this.genRandomComments(redom, Math.floor(Math.random() * 2));
        }
    }
}
```
### åŠ å…¥é…ç½®
æŠŠå†…å®¹æ¨¡å—ä¸­çš„å‡æ•°æ®ç”Ÿæˆå™¨`ContentFactory`å’Œæ•°æ®å¡«å……ç±»`ContentSeeder`æ·»åŠ åˆ°æ•°æ®åº“é…ç½®ä¸­ï¼Œè¿™æ ·å¡«å……å‘½ä»¤å°±å¯ä»¥è¯»å–äº†
```typescript
// src/config/database.config.ts

export const database = createDbConfig((configure) => ({
    connections: [
        {
            type: 'mysql',
            host: configure.env('DB_HOST', '127.0.0.1'),
            port: configure.env('DB_PORT', (v) => toNumber(v), 3306),
            username: configure.env('DB_USER', 'root'),
            password: configure.env('DB_PASSWORD', 'root'),
            database: configure.env('DB_NAME', '3r-room'),
            seeders: [ContentSeeder],
            factories: [ContentFactory],
        },
    ],
}));
```
### è¿è¡Œå‘½ä»¤
æœ€åé€šè¿‡è¿è¡Œ`pnpm cli dbs`æˆ–è€…`pnpm cli dbmr -s`æ¥å¡«å……æ•°æ®
